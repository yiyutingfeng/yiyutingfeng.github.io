<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Doris的数据模型</title>
    <url>/2023/08/07/02/</url>
    <content><![CDATA[<h1>Doris数据模型</h1>
<p>Doris 数据模型上目前分为三类:</p>
<ul>
<li>AGGREGATE（聚合模型）</li>
<li>UNIQUE（唯一主键模型）</li>
<li>DUPLICATE（明细模型）</li>
</ul>
<div class="note info"><p><strong>说明</strong></p>
<ol>
<li>在 Aggregate、Unique 和 Duplicate 三种数据模型中。底层的数据存储，是按照各自建表语句中，AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 中指定的列（<strong>不支持任意列，必须为前n列</strong>）进行排序存储的</li>
<li>三种模型都涉及前缀索引，即在排序的基础上，实现的一种根据给定前缀列，快速查询数据的索引方式，属于Doris内建的智能索引之一。</li>
<li>在查询过滤时使用AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 中的指定列时，可以提高查询效率。</li>
<li>数据模型在建表时就已经确定，且无法修改</li>
</ol>
</div>
<p><strong>适用场景</strong>：</p>
<ul>
<li>AGGREGATE 模型适合有固定模式的报表类查询场景和多维分析业务</li>
<li>UNIQUE 模型适用于有主键唯一性约束需求的某些多维分析业务</li>
<li>DUPLICATE 模型适用于既没有主键，也没有聚合需求的场景</li>
</ul>
<h2 id="AGGREGATE模型">AGGREGATE模型</h2>
<h3 id="数据聚合">数据聚合</h3>
<p>假设有如下数据表模式：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>LARGEINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td></td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td></td>
<td>用户性别</td>
</tr>
<tr>
<td>last_visit_date</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>用户最后一次访问时间</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>INT</td>
<td>MAX</td>
<td>用户最大停留时间</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>INT</td>
<td>MIN</td>
<td>用户最小停留时间</td>
</tr>
</tbody>
</table>
<p>该模型将表中的列按照是否设置了 <code>AggregationType</code>，分为 Key (维度列) 和 Value（指标列）。没有设置 <code>AggregationType</code> 的，如 <code>user_id</code>、<code>date</code>、<code>age</code> … 等称为 <strong>Key</strong>，而设置了 <code>AggregationType</code> 的称为 <strong>Value</strong>。</p>
<p>如果转换成建表语句则如下（省略建表语句中的 Partition 和 Distribution 信息）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `<span class="type">date</span>` <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;数据灌入日期时间&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `last_visit_date` DATETIME REPLACE <span class="keyword">DEFAULT</span> &quot;1970-01-01 00:00:00&quot; COMMENT &quot;用户最后一次访问时间&quot;,</span><br><span class="line">    `cost` <span class="type">BIGINT</span> SUM <span class="keyword">DEFAULT</span> &quot;0&quot; COMMENT &quot;用户总消费&quot;,</span><br><span class="line">    `max_dwell_time` <span class="type">INT</span> MAX <span class="keyword">DEFAULT</span> &quot;0&quot; COMMENT &quot;用户最大停留时间&quot;,</span><br><span class="line">    `min_dwell_time` <span class="type">INT</span> MIN <span class="keyword">DEFAULT</span> &quot;99999&quot; COMMENT &quot;用户最小停留时间&quot;</span><br><span class="line">)</span><br><span class="line">AGGREGATE KEY(`user_id`, `<span class="type">date</span>`, `city`, `age`, `sex`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>注意</strong></p>
<ol>
<li><code>AGGREGATE KEY</code> 必须为前连续N列</li>
<li>除<code>AGGREGATE KEY</code>指定的列，所有列都必须指定聚合方式</li>
</ol>
</div>
<p>AGGREGATE KEY相同时，新旧记录进行聚合，目前有以下聚合方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">聚合方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SUM</td>
<td>求和。适用数值类型。</td>
</tr>
<tr>
<td style="text-align:center">MIN</td>
<td>求最小值。适合数值类型。</td>
</tr>
<tr>
<td style="text-align:center">MAX</td>
<td>求最大值。适合数值类型。</td>
</tr>
<tr>
<td style="text-align:center">REPLACE</td>
<td>替换。对于维度列相同的行，指标列会按照导入的先后顺序，后导入的替换先导入的。</td>
</tr>
<tr>
<td style="text-align:center">REPLACE_IF_NOT_NULL</td>
<td>非空值替换。和 REPLACE 的区别在于对于null值，不做替换。字段默认值要给NULL，而不能是空字符串，否则会被替换成新字符串。</td>
</tr>
<tr>
<td style="text-align:center">HLL_UNION</td>
<td>HLL<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>类型的列的聚合方式，通过 HyperLogLog 算法聚合。</td>
</tr>
<tr>
<td style="text-align:center">BITMAP_UNION</td>
<td>BIMTAP<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>类型的列的聚合方式，进行位图的并集聚合。</td>
</tr>
</tbody>
</table>
<p>假设有以下导入数据（原始数据）：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>北京</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>上海</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>广州</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>那么当这批数据正确导入到 Doris 中后，Doris 中最终存储如下：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00:00</td>
<td>35</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>北京</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>上海</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>广州</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="发生聚合的阶段">发生聚合的阶段</h3>
<h4 id="导入阶段">导入阶段</h4>
<p>原始数据在导入过程中，会根据表结构中的Key进行分组，相同Key的Value会根据表中定义的AggregationType进行聚合</p>
<p>由于Doris采用的是MVCC（Multi-version Cocurrent Control，多版本并发控制）机制进行的并发控制，所以每一次新的导入都是一个新的版本</p>
<h4 id="Compaction阶段">Compaction阶段</h4>
<p>在不断导入新数据后，虽然每个批次的数据都在导入阶段完成了聚合，但不同版本之间的数据仍存在相同key但value没有聚合的情况，这时候就需要Compaction对不同版本的数据进行合并，对数据进行二次聚合</p>
<h4 id="查询阶段">查询阶段</h4>
<p>由于Compaction是异步的，在用户查询的数据仍存在多个版本时，为保证查询结果一致，会获取所有版本的数据，再做一次聚合，将聚合后的结果展示给用户。</p>
<p>经过聚合，Doris 中最终只会存储聚合后的数据。换句话说，即明细数据会丢失，用户不能够再查询到聚合前的明细数据了。经过聚合，Doris 中最终只会存储聚合后的数据。换句话说，即明细数据会丢失，用户不能够再查询到聚合前的明细数据了。</p>
<h3 id="时序图">时序图</h3>
<ol>
<li>
<p>insert与compact阶段以某一批次加载中<code>insert</code>阶段与<code>compaction</code>阶段的聚合操作,以聚合方法为<code>SUM</code>为例,时序图如下：<br>
<img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/insert_and_compaction_agg.png" alt=""></p>
</li>
<li>
<p>查询阶段<br>
<img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/select_agg.png" alt=""></p>
</li>
</ol>
<p>聚合方法在工厂类<code>AggregateFunctionSimpleFactory</code>中注册，使用时通过<code>AggregateFunctionSimpleFactory</code>获取对应聚合方法类的指针<code>AggregateFunctionPtr</code>执行聚合操作</p>
<h3 id="适用场景">适用场景</h3>
<p>AGGREGATE模型可以提前聚合数据, 极大地降低聚合查询时所需扫描的数据量和查询的计算量，非常适合有固定模式的报表类查询场景和多维分析业务。</p>
<h3 id="缺点">缺点</h3>
<p>该模型对 count(*) 查询很不友好。同时因为固定了 Value 列上的聚合方式，在进行其他类型的聚合查询时，需要考虑语意正确性。</p>
<p>假设表结构如下：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>LARGEINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
</tbody>
</table>
<p>假设存储引擎中有如下两个已经导入完成的批次的数据：</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>可以看到，用户 10001 分属在两个导入批次中的数据还没有聚合。但是为了保证用户只能查询到如下最终聚合后的数据, 会在查询引擎中加入了聚合算子，来保证数据对外的一致性：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>另外，在聚合列（Value）上，执行与聚合类型不一致的聚合类查询时，要注意语意。比如我们在如上示例中执行如下查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(cost) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>得到的结果是 5，而不是 1。</p>
<p>同时，这种一致性保证，在某些查询中，会极大的降低查询效率。</p>
<p>我们以最基本的 count(*) 查询为例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>在其他数据库中，这类查询都会很快的返回结果。因为在实现上，我们可以通过如“导入时对行进行计数，保存 count 的统计信息”，或者在查询时“仅扫描某一列数据，获得 count 值”的方式，只需很小的开销，即可获得查询结果。但是在 Doris 的聚合模型中，这种查询的开销<strong>非常大</strong>。</p>
<p>以刚才的数据为例：</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>因为最终的聚合结果为：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>所以，<code>select count(*) from table;</code> 的正确结果应该为 <strong>4</strong>。但如果我们只扫描 <code>user_id</code> 这一列，如果加上查询时聚合，最终得到的结果是 <strong>3</strong>（10001, 10002, 10003）。而如果不加查询时聚合，则得到的结果是 <strong>5</strong>（两批次一共5行数据）。可见这两个结果都是不对的。</p>
<p>为了得到正确的结果，我们必须同时读取 <code>user_id</code> 和 <code>date</code> 这两列的数据，<strong>再加上查询时聚合</strong>，才能返回 <strong>4</strong> 这个正确的结果。也就是说，在 count(*) 查询中，Doris 必须扫描所有的 AGGREGATE KEY 列（这里就是 <code>user_id</code> 和 <code>date</code>），并且聚合后，才能得到语意正确的结果。当聚合列非常多时，count(*) 查询需要扫描大量的数据。</p>
<p>因此，当业务上有频繁的 count(*) 查询时，我们建议用户通过增加一个<strong>值恒为 1 的，聚合类型为 SUM 的列来模拟 count(*)</strong>。如刚才的例子中的表结构，我们修改如下：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregateType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
<tr>
<td>count</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用于计算count</td>
</tr>
</tbody>
</table>
<p>增加一个 count 列，并且导入数据中，该列值<strong>恒为 1</strong>。则 <code>select count(*) from table;</code> 的结果等价于 <code>select sum(count) from table;</code>。而后者的查询效率将远高于前者。不过这种方式也有使用限制，就是用户需要自行保证，不会重复导入 AGGREGATE KEY 列都相同的行。否则，<code>select sum(count) from table;</code> 只能表述原始导入的行数，而不是 <code>select count(*) from table;</code> 的语义。</p>
<p>另一种方式，就是 <strong>将如上的 <code>count</code> 列的聚合类型改为 REPLACE，且依然值恒为 1</strong>。那么 <code>select sum(count) from table;</code> 和 <code>select count(*) from table;</code> 的结果将是一致的。并且这种方式，没有导入重复行的限制。</p>
<h2 id="UNIQUE模型">UNIQUE模型</h2>
<p>在1.2版本之前，该模型本质上是聚合模型的一个特例，也是一种简化的表结构表示方式。实现上和 AGGREGATE 模型 的 REPLACE 聚合方法一样，二者本质上相同，由于实现方式是读时合并（merge on read)，因此在一些聚合查询上性能不佳，自1.2版本 UNIQUE 模型引入新的实现方式，写时合并（merge on write），通过在写入时做一些额外的工作，实现了最优的查询性能，该实现有更好的聚合查询性能。默认情况下写时合并是关闭的。</p>
<h3 id="读时合并（与聚合模型相同的实现方式）">读时合并（与聚合模型相同的实现方式）</h3>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>IsKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td>Yes</td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td>Yes</td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>No</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>No</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>No</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>No</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>No</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>No</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>这是一个典型的用户基础信息表。这类数据没有聚合需求，只需保证主键唯一性。（这里的主键为 user_id + username）。那么我们的建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>而这个表结构，完全同等于以下使用聚合模型描述的表结构：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td></td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>REPLACE</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>REPLACE</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>REPLACE</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>REPLACE</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>REPLACE</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>及建表语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) REPLACE COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> REPLACE COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT REPLACE COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT REPLACE COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) REPLACE COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME REPLACE COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line">AGGREGATE KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="写时合并">写时合并</h3>
<p>Unqiue 模型的写时合并实现，与聚合模型是完全不同的两种模型了，查询性能更接近于 Duplicate 模型，在有主键约束需求的场景上相比聚合模型有较大的查询性能优势，尤其是在聚合查询以及需要用索引过滤大量数据的查询中。</p>
<p>写时合并默认关闭，用户可以通过添加下面的property来开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;enable_unique_key_merge_on_write&quot; <span class="operator">=</span> &quot;true&quot;</span><br></pre></td></tr></table></figure>
<p>仍然以上面的表为例，建表语句为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;,</span><br><span class="line">&quot;enable_unique_key_merge_on_write&quot; <span class="operator">=</span> &quot;true&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用这种建表语句建出来的表结构，与聚合模型就完全不同了：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td></td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>NONE</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>NONE</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>NONE</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>NONE</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>NONE</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>NONE</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>在开启了写时合并选项的Unique表上，数据在导入阶段就会去将被覆盖和被更新的数据进行标记删除，同时将新的数据写入新的文件。在查询的时候，所有被标记删除的数据都会在文件级别被过滤掉，读取出来的数据就都是最新的数据，消除掉了读时合并中的数据聚合过程，并且能够在很多情况下支持多种谓词的下推。因此在许多场景都能带来比较大的性能提升，尤其是在有聚合查询的情况下。</p>
<div class="note warning"><ol>
<li>新的<code>Merge-on-write</code>实现默认关闭，且只能在建表时通过指定<code>property</code>的方式打开。</li>
<li>旧的<code>Merge-on-read</code>的实现无法无缝升级到新版本的实现（数据组织方式完全不同），如果需要改为使用写时合并的实现版本，需要手动执行<code>insert into unique-mow-table select * from source table</code>.</li>
<li>在Unique模型上独有的<code>delete sign</code>和<code>sequence col</code>，在写时合并的新版实现中仍可以正常使用，用法没有变化。</li>
</ol>
</div>
<h3 id="Unique模型的写时合并实现">Unique模型的写时合并实现</h3>
<p>Unique模型的写时合并实现没有聚合模型的局限性，还是以刚才的数据为例，写时合并为每次导入的rowset增加了对应的delete bitmap，来标记哪些数据被覆盖。第一批数据导入后状态如下</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
<td>false</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>当第二批数据导入完成后，第一批数据中重复的行就会被标记为已删除，此时两批数据状态如下</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
<td>false</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
<td>false</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>在查询时，所有在delete bitmap中被标记删除的数据都不会读出来，因此也无需进行做任何数据聚合，上述数据中有效的行数为4行，查询出的结果也应该是4行，也就可以采取开销最小的方式来获取结果，即前面提到的“仅扫描某一列数据，获得 count 值”的方式。</p>
<p>据官方文档介绍，在测试环境中，count(*) 查询在 Unique 模型的写时合并实现上的性能，相比聚合模型有10倍以上的提升。</p>
<h3 id="写时合并时序图">写时合并时序图</h3>
<p><img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/merge_on_write_unique.png" alt=""></p>
<h3 id="缺点-2">缺点</h3>
<ol>
<li>无法利用 ROLLUP 等预聚合带来的查询优势。对于聚合查询有较高性能需求的用户，推荐使用自1.2版本加入的写时合并实现。</li>
<li>Unique 模型仅支持整行更新，如果用户既需要唯一主键约束，又需要更新部分列（例如将多张源表导入到一张 doris 表的情形），则可以考虑使用 Aggregate 模型，同时将非主键列的聚合类型设置为 REPLACE_IF_NOT_NULL。</li>
</ol>
<h2 id="DUPLICATE模型">DUPLICATE模型</h2>
<p>Duplicate 数据模型用于满足在某些多维分析场景下，数据既没有主键，也没有聚合需求的场景。</p>
<p>这种数据模型区别于 Aggregate 和 Unique 模型。数据完全按照导入文件中的数据进行存储，不会有任何聚合。即使两行数据完全相同，也都会保留。 而在建表语句中指定的 DUPLICATE KEY，只是用来指明底层数据按照那些列进行排序。</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>SortKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>timestamp</td>
<td>DATETIME</td>
<td>Yes</td>
<td>日志时间</td>
</tr>
<tr>
<td>type</td>
<td>INT</td>
<td>Yes</td>
<td>日志类型</td>
</tr>
<tr>
<td>error_code</td>
<td>INT</td>
<td>Yes</td>
<td>错误码</td>
</tr>
<tr>
<td>error_msg</td>
<td>VARCHAR(1024)</td>
<td>No</td>
<td>错误详细信息</td>
</tr>
<tr>
<td>op_id</td>
<td>BIGINT</td>
<td>No</td>
<td>负责人id</td>
</tr>
<tr>
<td>op_time</td>
<td>DATETIME</td>
<td>No</td>
<td>处理时间</td>
</tr>
</tbody>
</table>
<p>建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `<span class="type">timestamp</span>` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;日志时间&quot;,</span><br><span class="line">    `type` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;日志类型&quot;,</span><br><span class="line">    `error_code` <span class="type">INT</span> COMMENT &quot;错误码&quot;,</span><br><span class="line">    `error_msg` <span class="type">VARCHAR</span>(<span class="number">1024</span>) COMMENT &quot;错误详细信息&quot;,</span><br><span class="line">    `op_id` <span class="type">BIGINT</span> COMMENT &quot;负责人id&quot;,</span><br><span class="line">    `op_time` DATETIME COMMENT &quot;处理时间&quot;</span><br><span class="line">)</span><br><span class="line">DUPLICATE KEY(`<span class="type">timestamp</span>`, `type`, `error_code`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`type`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种数据模型区别于 Aggregate 和 Unique 模型。数据完全按照导入文件中的数据进行存储，不会有任何聚合。即使两行数据完全相同，也都会保留。 而在建表语句中指定的 DUPLICATE KEY，只是用来指明底层数据按照那些列进行排序。</p>
<h3 id="时序图-2">时序图</h3>
<p>与<a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">Aggregate模型一样，仅没有聚合操作</a></p>
<h3 id="适用场景-2">适用场景</h3>
<p>适用于既没有聚合需求，又没有主键唯一性约束的原始数据的存储</p>
<h3 id="缺点-3">缺点</h3>
<p>无法利用预聚合的特性</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://github.com/apache/doris/tree/branch-2.0">Doris 2.0.0 版源码</a><br>
<a href="https://doris.apache.org/zh-CN/docs/dev/data-table/data-model">Doris官方文档-数据表设计&gt;数据模型</a><br>
<a href="https://doris.apache.org/zh-CN/docs/dev/data-table/index/index-overview">Doris官方文档-数据表设计&gt;索引&gt;索引概述</a><br>
<a href="https://doris.apache.org/zh-CN/docs/dev/data-table/best-practice">Doris官方文档-数据表设计&gt;最佳实践</a><br><a href="https://zhuanlan.zhihu.com/p/426919326">悄悄学习Doris，偷偷惊艳所有人 | Apache Doris四万字小总结</a><br>
<a href="https://www.modb.pro/db/583790">Doris数据模型----三种数据模型讲解的非常到位</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在 Apache Doris 中，HLL（HyperLogLog）是一种用于基数估计的数据类型。它可以高效地估计一个集合中不同元素的数量，而无需存储实际的元素值。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在 Apache Doris 中，Bitmap 是一种用于高效压缩和查询位图索引数据的数据类型。它可以有效地表示包含大量重复值的列，并且在聚合、过滤和连接等操作中提供了显著的性能优势。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>Doris</category>
      </categories>
      <tags>
        <tag>Doris</tag>
        <tag>Aggregate模型</tag>
        <tag>Unique模型</tag>
        <tag>Duplicate模型</tag>
      </tags>
  </entry>
  <entry>
    <title>CirroData LOB 数据类型</title>
    <url>/2022/07/05/32/</url>
    <content><![CDATA[<h3 id="LOB类型">LOB类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">存储对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BLOB</td>
<td style="text-align:center">存储二进制数据</td>
</tr>
<tr>
<td style="text-align:center">CLOB</td>
<td style="text-align:center">存储字符数据，使用UTF-8编码</td>
</tr>
</tbody>
</table>
<h3 id="LOB存储方式">LOB存储方式</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据长度</th>
<th style="text-align:center">存储类型</th>
<th style="text-align:center">存放位置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;= 4KB</td>
<td style="text-align:center">LOB_INLINE</td>
<td style="text-align:center">以dp文件存储</td>
</tr>
<tr>
<td style="text-align:center">&gt; 4KB</td>
<td style="text-align:center">LOB_LOCATOR</td>
<td style="text-align:center">hdfs指定位置</td>
</tr>
</tbody>
</table>
<div class="note info"><h4 id="说明">说明</h4>
<p>存储类型为LOB_LOCATOR时,不代表dp为空,dp文件存放的lob索引文件名偏移量等信息;<br>
先读取dp中lob索引文件的信息,根据信息再从索引文件中获取lob数据文件的文件名偏移量等信息,最后根据索引信息获取lob具体数据</p>
</div>
<p>LOB_LOCATOR存储位置</p>
<ol>
<li>正常情况:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/xcloud_name/cluster_name.data/db_name/schema_name/table_id/session_id/LOB/lob_file_name</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>LLVM计算:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/xcloud_name/cluster_name.data/SYS.TEMP/db_name/schema_name/session_id/LOB/lob_file_name</span><br></pre></td></tr></table></figure>
<div class="note warning"><h4 id="注意">注意</h4>
<p>Writer会根据数据长度设置Lob存储类型读取lob数据时，需要根据存储类型区分读取方式，LOB_INLINE直接从lob中读取，LOB_LOCATOR使用Reader读取</p>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int32_t</span> LOB_INLINE_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<h3 id="LOB文件命名">LOB文件命名</h3>
<h4 id="普通文件">普通文件</h4>
<ul>
<li>索引文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lob.[trans_id].[unique_id].[hostname]_[pid].index</span><br></pre></td></tr></table></figure>
<ul>
<li>数据文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lob.[trans_id].[unique_id].[hostname]_[pid]</span><br></pre></td></tr></table></figure>
<h4 id="llvm计算文件">llvm计算文件</h4>
<ul>
<li>索引文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lob.llvm.[unique_id].[hostname]_[pid].index</span><br></pre></td></tr></table></figure>
<ul>
<li>数据文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lob.llvm.[unique_id].[hostname]_[pid]</span><br></pre></td></tr></table></figure>
<div class="note info"><h4 id="说明">说明</h4>
<p>索引文件和数据文件成对出现，索引文件的文件名仅比数据文件的文件名多<code>.index</code>后缀</p>
</div>
<h3 id="相关配置参数">相关配置参数</h3>
<div class="tabs" id="lob"><ul class="nav-tabs"><li class="tab active"><a href="#lob-1">3.0</a></li><li class="tab"><a href="#lob-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lob-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>compaction_lob_file_valid_threshold</td>
<td>每个lob数据文件中允许无效的lob个数占总lob个数的比例小于该比例.</td>
<td>double</td>
<td>0.5</td>
<td>(0, 1]</td>
</tr>
<tr>
<td>compaction_lob_tiny_file_num_threshold</td>
<td>compaction时,LOB微小文件必须进行compaction的数据阈值.微小文件的数量超过该值时,也必须进行compaction.</td>
<td>int32</td>
<td>50</td>
<td>[1, 100]</td>
</tr>
<tr>
<td>compaction_lob_tiny_file_size_threshold</td>
<td>lob compaction的时候,LOB文件大小小于该临界值的文件认为是小文件.</td>
<td>int64</td>
<td>1073741824</td>
<td>[128MB, 4GB]</td>
</tr>
<tr>
<td>lob_index_cache_num</td>
<td>LOB Writer中的索引Cache的数量.用于写入LOB数据.</td>
<td>int32</td>
<td>1024</td>
<td>[128, 4096]</td>
</tr>
<tr>
<td>lob_insert_cache_size</td>
<td>内部表加载时,用于拷贝LOB数据的缓存大小.</td>
<td>int32</td>
<td>1048576</td>
<td>[1MB, 2GB)</td>
</tr>
<tr>
<td>max_lob_size</td>
<td>LOB类型支持最大数据长度.</td>
<td>int64</td>
<td>4294967296</td>
<td>[16MB, 8GB]</td>
</tr>
<tr>
<td>lob_compression_type</td>
<td>LOB数据文件中的压缩类型.uncompressed: 表示不压缩;lz4: 表示lz4.</td>
<td>string</td>
<td>uncompressed</td>
<td>uncompresse,lz4</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="lob-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>lob_delete_factor</td>
<td>每个lob数据文件中允许无效的lob个数占总lob个数的比例小于该比例.</td>
<td>double</td>
<td>0.5</td>
<td>(0, 1]</td>
</tr>
<tr>
<td>lob_compaction_small_files_cnt</td>
<td>LOB小文件的数量达到该临界值的时候，也需要进行compaction.</td>
<td>int32</td>
<td>50</td>
<td>[1, 100]</td>
</tr>
<tr>
<td>lob_compaction_small_file_size</td>
<td>lob compaction的时候,LOB文件大小小于该临界值的文件认为是小文件.</td>
<td>int64</td>
<td>1073741824</td>
<td><div style="white-space: nowrap">[128MB, 4GB]</div></td>
</tr>
<tr>
<td>lob_writer_cache_index_cnt</td>
<td>每一个lob Writer缓存的lob索引的数量.</td>
<td>int32</td>
<td>1024</td>
<td>[128, 4096]</td>
</tr>
<tr>
<td>lob_copy_data_length</td>
<td>local insert时候，拷贝数据需要的缓存长度.</td>
<td>int32</td>
<td>1048576</td>
<td>[1MB, 2GB)</td>
</tr>
<tr>
<td>lob_max_data_size</td>
<td>lob类型支持最大数据长度为4G.</td>
<td>int64</td>
<td>4294967296</td>
<td>[16MB, 8GB]</td>
</tr>
<tr>
<td>lob_compressionType</td>
<td>lob数据压缩方式，默认0：表示不压缩，1：表示lz4.</td>
<td>int32</td>
<td>0</td>
<td>{0, 1}</td>
</tr>
</tbody>
</table></div></div></div>
<h3 id="LOB文件大小">LOB文件大小</h3>
<p>单个lob文件最大1TB</p>
<h3 id="lob触发compaction的两种机制">lob触发compaction的两种机制</h3>
<ol>
<li>update操作，lob文件中无效lob比例 &gt;= <code>lob_delete_factor</code></li>
<li>lob小文件数量 &gt;= <code>lob_compaction_small_files_cnt</code></li>
</ol>
<div class="note info"><h4 id="说明">说明</h4>
<ol>
<li>update操作才会产生无效数据，delete不会</li>
<li>LOCATOR存储的lob,若update后的数据长度小于4KB,是不会进行compaction的，此时lob属于INLINE存储，原lob仅增加delete标记</li>
</ol>
</div>
<div class="note danger"><h4 id="使用为NULL的LOB">使用为NULL的LOB</h4>
<p>lob为null，其成员函数几乎都不可使用，强制使用会访问空指针（<code>m_lobInfo = null</code>），导致崩溃，可使用<code>XCLob::IsNull()</code>方法判断lob是否为null</p>
</div>
<h3 id="export-clob">export clob</h3>
<p>支持导出真实数据，如果数据太长，依然用<code>&lt;CLOB&gt;</code>替代真实数据,长度限制查看配置,导出和导入用的同一套配置参数<code>csv_file_with_clob_max_buffer_size</code>和<code>csv_file_max_buffer_size</code></p>
<h3 id="blob加载多媒体文件">blob加载多媒体文件</h3>
<p>通过csv文件进行加载，csv文件中写入多媒体文件的路径</p>
<p>示例：存在<code>/home/gaoyuanfeng/3.0/blob_insert.csv</code>该路径的csv文件，文件内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/home/gaoyuanfeng/3.0/picture2.png&quot;</span><br><span class="line">&quot;/home/gaoyuanfeng/3.0/picture2.png&quot;</span><br></pre></td></tr></table></figure>
<p>inset使用<code>/*+LOB_FROM_EXTFILE*/</code>hit进行加载</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> BLOB_TEST(picture <span class="type">BLOB</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="comment">/*+LOB_FROM_EXTFILE*/</span> BLOB_TEST <span class="string">&#x27;/home/gaoyuanfeng/3.0/blob_insert.csv&#x27;</span> SEPARATOR <span class="string">&#x27;;&#x27;</span> DELIMITER <span class="string">&#x27;&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>LOB</tag>
        <tag>CLOB</tag>
        <tag>BLOB</tag>
      </tags>
  </entry>
  <entry>
    <title>CirroData NUMBER 数据类型</title>
    <url>/2022/07/11/55/</url>
    <content><![CDATA[<h2 id="number可表示范围">number可表示范围</h2>
<p>(-1E252, -1E-260], 0, [1E-260, 1E252)</p>
<h2 id="number精度与刻度">number精度与刻度</h2>
<h3 id="精度">精度</h3>
<p><strong>说明</strong>：精度（precision）是NUMBER表示的数字中，精确的有效数字位数（NUMBER中记录的数字有可能超过精度，但是不保证精度范围之外的数字精确）。<br>
<strong>取值范围</strong>：[1, 38]。</p>
<h3 id="刻度">刻度</h3>
<p><strong>说明</strong>：刻度（scale）是精确到小数点后的位数。scale &gt; 0时，表示该类型精确到小数点后scale位；scale = 0时，表示该类型为整数；scale &lt; 0时，表示该类型精确到小数点前-scale位。<br>
<strong>取值范围</strong>：[-84, 127]。</p>
<h2 id="number存储规则">number存储规则</h2>
<p>number类型占24个字节，每2个字节作为一个单元，共12个单元，每个单位最大可存储4位数字。第一个单元是索引部分，既用于表示数值正负，也用于记录数值整数部分占用多少个单元，剩余11个单元用于存储具体数值，称为数值部分。</p>
<h3 id="索引部分存储规则">索引部分存储规则</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> IndexType XCNumber::S_POSITIVE_INDEX_BASE = <span class="number">192</span>;</span><br><span class="line"><span class="type">const</span> IndexType XCNumber::S_NEGATIVE_INDEX_BASE = <span class="number">63</span>;</span><br><span class="line"><span class="type">const</span> IndexType XCNumber::S_ZERO_INDEX_BASE = <span class="number">128</span>;</span><br></pre></td></tr></table></figure>
<h4 id="正数">正数</h4>
<p>索引值 = <code>S_POSITIVE_INDEX_BASE</code> + 整数部分单元格的个数例如: 数值1234567.1234567存储位number类型，索引值 = 192 + 2 = 194</p>
<p>若索引值n小于<code>S_POSITIVE_INDEX_BASE</code>，则表示有效数字前有<code>192-n</code>个单元格是0<br>
例如0.000000123   索引值为191</p>
<p>索引值取值范围[128, 255]</p>
<h4 id="负数">负数</h4>
<p>索引值 = <code>S_NEGATIVE_INDEX_BASE</code> - 整数部分单元格的个数例如: 数值-1234567.1234567存储为number类型，索引值 = 63 - 2 = 61</p>
<p>若索引值n大于<code>S_NEGATIVE_INDEX_BASE</code>，则表示有效数字前有<code>n-63</code>个单元格是0<br>
例如: -0.000000000123   索引值是65</p>
<p>索引值取值范围[0, 127]</p>
<h4 id="0">0</h4>
<p>索引值 = <code>S_ZERO_INDEX_BASE</code> = 128</p>
<blockquote>
<p>注意: 0的索引值是128，但索引值为128的数不一定是0，例如1E-260的索引值也是128</p>
</blockquote>
<h3 id="数值部分存储规则">数值部分存储规则</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> TailType XCNumber::S_POSITIVE_TAIL = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> TailType XCNumber::S_NEGATIVE_TAIL = <span class="number">10002</span>;</span><br><span class="line"><span class="type">const</span> TailType XCNumbeer::S_POSITIVE_BASE = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> TailType XCNumber::S_NEGATIVE_BASE = <span class="number">10001</span>;</span><br></pre></td></tr></table></figure>
<p>以1234567.1234567举例</p>
<h4 id="数值划分">数值划分</h4>
<ol>
<li>整数部分: 每4位占一个单元，从低位开始划分，从高位开始存储例如: 1234567  共7位，占2个单元，123 占数值部分第1个单元，4567占第2个单元</li>
<li>小数部分: 每4位占一个单元，从高位开始划分，从高位开始存储，低位不满4字节末尾填充0补齐例如: .1234567 共7位，占2个单元，1234占数值部分第3个单元，5670占第4个单元</li>
</ol>
<p>1234567.1234567的按单元个划分如下</p>
<table>
<thead>
<tr>
<th>123</th>
<th>4567</th>
<th>1234</th>
<th>5670</th>
</tr>
</thead>
</table>
<h4 id="数值存储">数值存储</h4>
<ol>
<li>
<p><strong>正数</strong>: 默认11个单元初始化为<code>S_POSITIVE_TAIL</code>,存储内容为原值单元划分后的值加上<code>S_POSITIVE_BASE</code>，即每个单元初始化为0，每个单元的值为：原值 + 1</p>
<p>例如: 1234567.1234567<br>
初始单元格:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
</table>
<p>原值单元格划分为:</p>
<table>
<thead>
<tr>
<th>123</th>
<th>4567</th>
<th>1234</th>
<th>5670</th>
</tr>
</thead>
</table>
<p>实际存储为:</p>
<table>
<thead>
<tr>
<th>124</th>
<th>4568</th>
<th>1235</th>
<th>5671</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
</tr>
</thead>
</table>
</li>
<li>
<p><strong>负数</strong>: 默认11个单元初始化为<code>S_NEGATIVE_TAIL</code>,存储内容为<code>S_NEGATIVE_BASE</code>减去原值单元划分后的值，即每个单元初始化为10002，每个单元的值为：10001 - 原值</p>
<p>例如: -1234567.1234567<br>
初始单元格:</p>
<table>
<thead>
<tr>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
</tr>
</thead>
</table>
<p>原值单元格划分为:</p>
<table>
<thead>
<tr>
<th>123</th>
<th>4567</th>
<th>1234</th>
<th>5670</th>
</tr>
</thead>
</table>
<p>实际存储为:</p>
<table>
<thead>
<tr>
<th>9878</th>
<th>5434</th>
<th>8767</th>
<th>4331</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
<th>10002</th>
</tr>
</thead>
</table>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>CirroData 实用SQL</title>
    <url>/2022/07/08/37/</url>
    <content><![CDATA[<h3 id="删除非空数据库">删除非空数据库</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE db_name CASCADE</span><br></pre></td></tr></table></figure>
<h3 id="删除非空用户">删除非空用户</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> user_name CASCADE</span><br></pre></td></tr></table></figure>
<h3 id="动态参数">动态参数</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- cluster用户</span></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE dbname <span class="keyword">SET</span> <span class="keyword">PARAMETER</span> parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$CLUSTER_PARAMETERS_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- db用户</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> PARAM <span class="keyword">SET</span> parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> PC PARAM <span class="keyword">SET</span> pc_name.parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$DB_PARAMETERS_INFO;</span><br></pre></td></tr></table></figure>
<h3 id="查询有哪些系统表">查询有哪些系统表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$SYS_VTABLES_VIEW;</span><br></pre></td></tr></table></figure>
<h3 id="GB18030">GB18030</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE DB_GB18030 <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;GB18030&#x27;</span> COMMENT <span class="string">&#x27;GB18030&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="创建有序表">创建有序表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="comment">/*+ORDERED_TABLE*/</span> <span class="keyword">TABLE</span> table_name(id LONG, name STRING, birthday <span class="type">DATE</span>) SLICED <span class="keyword">BY</span>(birthday, name, id) <span class="keyword">INTO</span> <span class="number">1</span> SLICES</span><br></pre></td></tr></table></figure>
<h3 id="检查是否为有序表">检查是否为有序表</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name, is_ordered <span class="keyword">from</span> v$user_tables</span><br></pre></td></tr></table></figure>
<h3 id="查看当前DB空闲节点">查看当前DB空闲节点</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> V$DB_FREE_PUS;</span><br></pre></td></tr></table></figure>
<h3 id="清除DB的所有进程组配置信息-systemadmin用户">清除DB的所有进程组配置信息(systemadmin用户)</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER PC CONFIG CLEAN ALL ON db_name;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>CirroData</tag>
      </tags>
  </entry>
  <entry>
    <title>3.0 checkin</title>
    <url>/2023/02/14/38/</url>
    <content><![CDATA[<p><a href="http://172.16.12.45/afe/#tab_id=view_job&amp;object_id=145411">checkin autotest</a></p>
<p>修改Clinet control file</p>
<table>
<thead>
<tr>
<th style="text-align:left">内容</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">172.16.44.46:6403</td>
<td style="text-align:left">行云计算引擎ip:port</td>
</tr>
<tr>
<td style="text-align:left">172.16.44.37:6456</td>
<td style="text-align:left">存储过程ip:port</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>checkin</tag>
      </tags>
  </entry>
  <entry>
    <title>kv组件部署脚本</title>
    <url>/2023/05/01/27/</url>
    <content><![CDATA[<h2 id="脚本使用方法">脚本使用方法</h2>
<h3 id="必要操作">必要操作</h3>
<ol>
<li>复制kv安装包到脚本所在目录</li>
<li>修改脚本中的<code>ARBITER_RPC_PORT</code>,<code>CARRIER_RPC_PORT</code>,<code>IP</code>三个变量</li>
</ol>
<h3 id="部署并启动kv">部署并启动kv</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh deploy</span><br></pre></td></tr></table></figure>
<h3 id="启动kv">启动kv</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh start</span><br></pre></td></tr></table></figure>
<h3 id="停止kv">停止kv</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh stop</span><br></pre></td></tr></table></figure>
<h3 id="清理kv">清理kv</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh clean</span><br></pre></td></tr></table></figure>
<h3 id="重启kv">重启kv</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh restart</span><br></pre></td></tr></table></figure>
<h3 id="更新kv-自动停止和清理旧版kv-自动识别新包-重新部署新kv">更新kv(自动停止和清理旧版kv,自动识别新包,重新部署新kv)</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh update</span><br></pre></td></tr></table></figure>
<h3 id="查看kv状态">查看kv状态</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kv_tools.sh status</span><br></pre></td></tr></table></figure>
<h2 id="kv-tools-sh脚本内容"><code>kv_tools.sh</code>脚本内容</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 支持单节点或多节点配置kv组件</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 单节点配置要求:</span></span><br><span class="line"><span class="comment"># ARBITER_RPC_PORT 与 CARRIER_RPC_PORT 分别至少配置3个端口号, IP个数仅配置1个</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 多节点配置要求:</span></span><br><span class="line"><span class="comment"># ARBITER_RPC_PORT 与 CARRIER_RPC_PORT 分别仅配置1个端口号, IP个数至少配置3个</span></span><br><span class="line"><span class="comment"># 每个节点下的该脚本配置需一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># arbiter rpc_port 需修改</span></span><br><span class="line">ARBITER_RPC_PORT=(15353 15354 15355)</span><br><span class="line"></span><br><span class="line"><span class="comment"># carrier rpc_port 需修改</span></span><br><span class="line">CARRIER_RPC_PORT=(15356 15357 15358)</span><br><span class="line"></span><br><span class="line"><span class="comment"># kv部署节点,至少3个节点,需修改,不填表示仅在当前节点配置kv组件</span></span><br><span class="line">IP=()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版包名是&#x27;ckv&#x27;,若为旧版kv,则需修改为&#x27;ckv&#x27;</span></span><br><span class="line">KV_NAME=<span class="string">&quot;CirroKV&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="comment">##############################################</span></span><br><span class="line"><span class="comment"># 解压安装包</span></span><br><span class="line"><span class="comment"># $1: 安装包路径</span></span><br><span class="line"><span class="comment"># $2: 解压目录</span></span><br><span class="line"><span class="keyword">function</span> extract_package &#123;</span><br><span class="line">    <span class="built_in">local</span> package_path=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> extract_dir=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> package_name=$(<span class="built_in">basename</span> <span class="string">&quot;<span class="variable">$&#123;package_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;package_name##*.&#125;</span>&quot;</span> == <span class="string">&quot;zip&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># unzip支持解压zip</span></span><br><span class="line">        unzip <span class="string">&quot;<span class="variable">$&#123;package_path&#125;</span>&quot;</span> -d <span class="string">&quot;<span class="variable">$&#123;extract_dir&#125;</span>&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;package_name##*.&#125;</span>&quot;</span> == <span class="string">&quot;tar&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;package_name##*.&#125;</span>&quot;</span> == <span class="string">&quot;gz&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;package_name##*.&#125;</span>&quot;</span> == <span class="string">&quot;bz2&quot;</span> ] || [ <span class="string">&quot;<span class="variable">$&#123;package_name##*.&#125;</span>&quot;</span> == <span class="string">&quot;xz&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># tar支持解压tar、tar.gz、tar.bz2、tar.xz</span></span><br><span class="line">        tar xf <span class="string">&quot;<span class="variable">$&#123;package_path&#125;</span>&quot;</span> -C <span class="string">&quot;<span class="variable">$&#123;extract_dir&#125;</span>&quot;</span> &gt; /dev/null</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;不支持的安装包格式&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;解压完成&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查端口是否被占用</span></span><br><span class="line"><span class="comment"># $1: 端口号</span></span><br><span class="line"><span class="keyword">function</span> check_port &#123;</span><br><span class="line">    <span class="built_in">local</span> port=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> netstat_result=$(netstat -ant)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查端口是否已经被占用</span></span><br><span class="line">    <span class="keyword">if</span> grep -q <span class="string">&quot;<span class="variable">$&#123;port&#125;</span>&quot;</span> &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$&#123;netstat_result&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;port&#125;</span>端口可能还未释放,10后重试...&quot;</span></span><br><span class="line">        <span class="comment"># 设置超时时间为60秒</span></span><br><span class="line">        <span class="built_in">local</span> <span class="built_in">timeout</span>=60</span><br><span class="line">        <span class="comment"># 获取当前时间戳</span></span><br><span class="line">        <span class="built_in">local</span> start_time=$(<span class="built_in">date</span> +%s)</span><br><span class="line">        <span class="comment"># 循环等待端口释放</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            <span class="comment"># 判断超时时间是否到达</span></span><br><span class="line">            <span class="keyword">if</span> [ $(($(date +%s)-start_time)) -ge <span class="variable">$timeout</span> ]</span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> -e <span class="string">&quot;\e[31m<span class="variable">$&#123;port&#125;</span>端口释放超时，请更换端口号\e[0m&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> -1</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            <span class="comment"># 等待10秒</span></span><br><span class="line">            <span class="built_in">sleep</span> 10</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;10s后再次重试...&quot;</span></span><br><span class="line">            <span class="comment"># 再次执行netstat命令并保存结果</span></span><br><span class="line">            netstat_result=$(netstat -ant)</span><br><span class="line">            <span class="comment"># 判断端口是否已经被释放</span></span><br><span class="line">            <span class="keyword">if</span> ! grep -q <span class="string">&quot;<span class="variable">$&#123;port&#125;</span>&quot;</span> &lt;&lt;&lt; <span class="string">&quot;<span class="variable">$&#123;netstat_result&#125;</span>&quot;</span></span><br><span class="line">            <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">return</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="comment"># $1: 配置文件路径</span></span><br><span class="line"><span class="comment"># $2: 要修改的选项名称</span></span><br><span class="line"><span class="comment"># $3: 要修改的选项值</span></span><br><span class="line"><span class="keyword">function</span> edit_config &#123;</span><br><span class="line">    <span class="built_in">local</span> config_file=<span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> option_name=<span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line">    <span class="built_in">local</span> option_value=<span class="string">&quot;<span class="variable">$3</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$&#123;config_file&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 获取选项所在行号</span></span><br><span class="line">        <span class="built_in">local</span> line=$(grep -nA10 <span class="string">&quot;&gt;<span class="variable">$&#123;option_name&#125;</span>&quot;</span> <span class="variable">$&#123;config_file&#125;</span> | grep <span class="string">&quot;current&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&#x27;-&#x27;</span> -f 1)</span><br><span class="line">        <span class="comment"># 生成替换字符串</span></span><br><span class="line">        <span class="built_in">local</span> replace_str=<span class="string">&quot;&lt;current&gt;<span class="variable">$&#123;option_value&#125;</span>&lt;/current&gt;&quot;</span></span><br><span class="line">        <span class="comment"># 替换字符串中的特殊字符</span></span><br><span class="line">        <span class="built_in">local</span> replace_str_escaped=$(<span class="built_in">echo</span> <span class="variable">$replace_str</span> | sed <span class="string">&#x27;s/\//\\\//g&#x27;</span>)</span><br><span class="line">        <span class="comment"># 设置选项值</span></span><br><span class="line">        sed -i <span class="string">&quot;<span class="variable">$&#123;line&#125;</span>s/.*/    <span class="variable">$&#123;replace_str_escaped&#125;</span>/&quot;</span> <span class="string">&quot;<span class="variable">$&#123;config_file&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;找不到配置文件 <span class="variable">$&#123;config_file&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;修改配置文件 <span class="variable">$&#123;config_file&#125;</span> 完成&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 kv</span></span><br><span class="line"><span class="comment"># $1: kv目录</span></span><br><span class="line"><span class="keyword">function</span> start_kv &#123;</span><br><span class="line">    <span class="built_in">local</span> kv_dir=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_start_script=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;start-ckv.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若kv_start_script为空,则说明该kv目录下没有start-ckv.sh脚本,则不启动kv</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;kv_start_script&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep -q <span class="string">&quot;arbiter&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 启动 arbiter server</span></span><br><span class="line">        <span class="variable">$&#123;kv_start_script&#125;</span> --arbiter=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ! ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep -q <span class="string">&quot;carrier&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 启动 carrier server</span></span><br><span class="line">        <span class="variable">$&#123;kv_start_script&#125;</span> --carrier=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 kv</span></span><br><span class="line"><span class="comment"># $1: kv目录</span></span><br><span class="line"><span class="keyword">function</span> stop_kv &#123;</span><br><span class="line">    <span class="built_in">local</span> kv_dir=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_stop_script=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;stop-ckv.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若kv_stop_script为空,则说明该kv目录下没有stop-ckv.sh脚本,则不停止kv</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;kv_stop_script&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep -q <span class="string">&quot;arbiter&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 停止 arbiter server</span></span><br><span class="line">        <span class="variable">$&#123;kv_stop_script&#125;</span> --arbiter=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查进程是否存在,存在则kill</span></span><br><span class="line">    <span class="built_in">local</span> arbiter_pid = $(ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep <span class="string">&quot;arbiter&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;arbiter_pid&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;kill arbiter server&quot;</span></span><br><span class="line">        <span class="built_in">kill</span> -9 <span class="variable">$&#123;arbiter_pid&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查进程是否存在,存在则kill</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep -q <span class="string">&quot;carrier&quot;</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 停止 carrier server</span></span><br><span class="line">        <span class="variable">$&#123;kv_stop_script&#125;</span> --carrier=1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查进程是否存在,存在则kill</span></span><br><span class="line">    <span class="built_in">local</span> carrier_pid = $(ps -ef | grep <span class="variable">$&#123;kv_dir&#125;</span> | grep <span class="string">&quot;carrier&quot;</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$&#123;carrier_pid&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;kill carrier server&quot;</span></span><br><span class="line">        <span class="built_in">kill</span> -9 <span class="variable">$&#123;carrier_pid&#125;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理 kv</span></span><br><span class="line"><span class="comment"># $1: kv目录</span></span><br><span class="line"><span class="keyword">function</span> clean_kv &#123;</span><br><span class="line">    <span class="built_in">local</span> kv_dir=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_clean_script=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;clean-ckv.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若kv_clean_script为空,则说明该kv目录下没有clean-ckv.sh脚本,则不清理kv</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;kv_clean_script&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先停止 kv</span></span><br><span class="line">    stop_kv <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 清理 kv</span></span><br><span class="line">    <span class="variable">$&#123;kv_clean_script&#125;</span> --all=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署kv</span></span><br><span class="line"><span class="comment"># $1: kv目录</span></span><br><span class="line"><span class="keyword">function</span> deploy_kv &#123;</span><br><span class="line">    <span class="built_in">local</span> kv_dir=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">local</span> arbiter_rpc_port=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">local</span> carrier_rpc_port=<span class="variable">$3</span></span><br><span class="line">    <span class="built_in">local</span> arbiter_addr_list=<span class="variable">$4</span></span><br><span class="line">    <span class="built_in">local</span> package_path=$(<span class="built_in">ls</span> -t *<span class="variable">$&#123;KV_NAME&#125;</span>*.tar.gz | <span class="built_in">head</span> -1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查函数参数是否为空</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$&#123;arbiter_rpc_port&#125;</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$&#123;carrier_rpc_port&#125;</span>&quot;</span> ] || [ -z <span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;函数参数不能为空&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查端口是否被占用</span></span><br><span class="line">    check_port <span class="string">&quot;<span class="variable">$&#123;arbiter_rpc_port&#125;</span>&quot;</span></span><br><span class="line">    check_port <span class="string">&quot;<span class="variable">$&#123;carrier_rpc_port&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$&#123;package_path&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;找不到安装包&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若未解压过,则解压安装包</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;KV_NAME&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        extract_package <span class="string">&quot;<span class="variable">$&#123;package_path&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> arbiter_conf_file=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;config_arbiter.xml&quot;</span>)</span><br><span class="line">    <span class="built_in">local</span> carrier_conf_file=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;config_carrier.xml&quot;</span>)</span><br><span class="line">    <span class="built_in">local</span> ckv_admin_conf_file=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;config_ckv_admin.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">declare</span> -a arbiter_data_dir carrier_data_dir arbiter_options_name carrier_options_name arbiter_options_value carrier_options_value</span><br><span class="line">    <span class="comment"># kv数据目录</span></span><br><span class="line">    arbiter_data_dir=(<span class="string">&quot;.ab_data&quot;</span> <span class="string">&quot;.ab_wal&quot;</span>)</span><br><span class="line">    carrier_data_dir=(<span class="string">&quot;.cr_data&quot;</span> <span class="string">&quot;.cr_wal&quot;</span> <span class="string">&quot;.cr_conf&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 arbiter 数据目录</span></span><br><span class="line">    <span class="built_in">local</span> i=0</span><br><span class="line">    <span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="variable">$&#123;#arbiter_data_dir[@]&#125;</span>; ++i))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;arbiter_data_dir[i]&#125;</span>&quot;</span> ]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;arbiter_data_dir[i]&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    arbiter_options_name=(<span class="string">&quot;rpc_port&quot;</span> <span class="string">&quot;arbiter_addr_list&quot;</span> <span class="string">&quot;data_dir&quot;</span> <span class="string">&quot;wal_dir&quot;</span>)</span><br><span class="line">    carrier_options_name=(<span class="string">&quot;rpc_port&quot;</span> <span class="string">&quot;arbiter_addr_list&quot;</span> <span class="string">&quot;data_dir&quot;</span> <span class="string">&quot;wal_dir&quot;</span> <span class="string">&quot;conf_dir&quot;</span>)</span><br><span class="line">    arbiter_options_value=(<span class="string">&quot;<span class="variable">$&#123;arbiter_rpc_port&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;arbiter_data_dir[0]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;arbiter_data_dir[1]&#125;</span>&quot;</span>)</span><br><span class="line">    carrier_options_value=(<span class="string">&quot;<span class="variable">$&#123;carrier_rpc_port&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;carrier_data_dir[0]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;carrier_data_dir[1]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>/<span class="variable">$&#123;carrier_data_dir[2]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_start_script=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;start-ckv.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改 arbiter 配置文件</span></span><br><span class="line">    <span class="built_in">local</span> j=0</span><br><span class="line">    <span class="keyword">for</span> ((j=<span class="number">0</span>; j&lt;<span class="variable">$&#123;#arbiter_options_name[@]&#125;</span>; ++j))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        edit_config <span class="string">&quot;<span class="variable">$&#123;arbiter_conf_file&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_options_name[j]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_options_value[j]&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改 carrier 配置文件</span></span><br><span class="line">    <span class="built_in">local</span> k=0</span><br><span class="line">    <span class="keyword">for</span> ((k=<span class="number">0</span>; k&lt;<span class="variable">$&#123;#carrier_options_name[@]&#125;</span>; ++k))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        edit_config <span class="string">&quot;<span class="variable">$&#123;carrier_conf_file&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;carrier_options_name[k]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;carrier_options_value[k]&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> ckv_admin_options_name=<span class="string">&quot;ckv_admin_arbiter_address_list&quot;</span></span><br><span class="line">    <span class="built_in">local</span> ckv_admin_options_value=<span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改 ckv-admin 配置文件</span></span><br><span class="line">    edit_config <span class="string">&quot;<span class="variable">$&#123;ckv_admin_conf_file&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ckv_admin_options_name&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ckv_admin_options_value&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动 kv</span></span><br><span class="line">    start_kv <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kv 状态</span></span><br><span class="line"><span class="comment"># $1: kv目录</span></span><br><span class="line"><span class="keyword">function</span> status_kv &#123;</span><br><span class="line">    <span class="built_in">local</span> kv_dir=<span class="variable">$1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -d <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_admin_script=$(find <span class="string">&quot;<span class="variable">$&#123;kv_dir&#125;</span>&quot;</span> -name <span class="string">&quot;ckv-admin.sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看 kv 状态</span></span><br><span class="line">    <span class="variable">$&#123;kv_admin_script&#125;</span> arbiter list</span><br><span class="line">    <span class="variable">$&#123;kv_admin_script&#125;</span> carrier list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主函数</span></span><br><span class="line"><span class="comment"># $1: 可选参数</span></span><br><span class="line"><span class="keyword">function</span> main &#123;</span><br><span class="line">    <span class="built_in">local</span> optional=<span class="variable">$1</span></span><br><span class="line">    <span class="built_in">declare</span> -a nodes kv_root_dirs</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;#IP[@]&#125;</span> -eq 0 ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> local_node=$(hostname -i | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">        nodes+=(<span class="variable">$&#123;local_node&#125;</span>)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> home=$(<span class="built_in">pwd</span>)</span><br><span class="line">    <span class="built_in">local</span> arbiter_size=<span class="variable">$&#123;#ARBITER_RPC_PORT[@]&#125;</span></span><br><span class="line">    <span class="built_in">local</span> carrier_size=<span class="variable">$&#123;#CARRIER_RPC_PORT[@]&#125;</span></span><br><span class="line">    <span class="built_in">local</span> ip_size=<span class="variable">$&#123;#nodes[@]&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ip数为1,端口数不小于3,即单节点多kv</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;ip_size&#125;</span> -eq 1 ]] &amp;&amp; [[ <span class="variable">$&#123;arbiter_size&#125;</span> -eq <span class="variable">$&#123;carrier_size&#125;</span> ]] &amp;&amp; [[ <span class="variable">$&#123;arbiter_size&#125;</span> -ge 3 ]] &amp;&amp; [[ <span class="variable">$&#123;carrier_size&#125;</span> -ge 3 ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">local</span> i=0</span><br><span class="line">        <span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="variable">$&#123;#ARBITER_RPC_PORT[@]&#125;</span>; ++i))</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            kv_root_dirs+=(<span class="variable">$&#123;home&#125;</span>/kv_store_<span class="variable">$&#123;i&#125;</span>)</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">elif</span> [[ <span class="variable">$&#123;ip_size&#125;</span> -ge 3 ]] &amp;&amp; [[ <span class="variable">$&#123;arbiter_size&#125;</span> -eq <span class="variable">$&#123;carrier_size&#125;</span> ]] &amp;&amp; [[ <span class="variable">$&#123;arbiter_size&#125;</span> -eq 1 ]] &amp;&amp; [[ <span class="variable">$&#123;carrier_size&#125;</span> -eq 1 ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        kv_root_dirs=(<span class="string">&quot;<span class="variable">$&#123;home&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;请检查kv_tools.sh配置是否正确&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ip数为<span class="variable">$&#123;ip_size&#125;</span>,arbiter_rpc_port数为<span class="variable">$&#123;arbiter_size&#125;</span>,carrier_rpc_port数为<span class="variable">$&#123;carrier_size&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> -1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> arbiter_addr_list=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">local</span> j=0</span><br><span class="line">    <span class="keyword">for</span> ((j=<span class="number">0</span>; j&lt;<span class="variable">$&#123;#nodes[@]&#125;</span>; ++j))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">local</span> host_name=$(awk -v s=<span class="variable">$&#123;nodes[j]&#125;</span> <span class="string">&#x27;$1==s&#123;print $2&#125;&#x27;</span> /etc/hosts)</span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;host_name&#125;</span> ]]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">local</span> k=0</span><br><span class="line">            <span class="keyword">for</span> ((k=<span class="number">0</span>; k&lt;<span class="variable">$&#123;#ARBITER_RPC_PORT[@]&#125;</span>; ++k))</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">                arbiter_addr_list+=<span class="string">&quot;<span class="variable">$&#123;host_name&#125;</span>:<span class="variable">$&#123;ARBITER_RPC_PORT[k]&#125;</span>,&quot;</span></span><br><span class="line">            <span class="keyword">done</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;/etc/hosts中找不到<span class="variable">$&#123;nodes[j]&#125;</span>对应的hostname&quot;</span></span><br><span class="line">            <span class="built_in">exit</span> -1</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 去除末尾的逗号</span></span><br><span class="line">    arbiter_addr_list=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$arbiter_addr_list</span>&quot;</span> | sed <span class="string">&#x27;s/,$//&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">local</span> kv_dir_size=<span class="variable">$&#123;#kv_root_dirs[@]&#125;</span></span><br><span class="line">    <span class="built_in">local</span> n=0</span><br><span class="line">    <span class="keyword">for</span> ((n=<span class="number">0</span>; n &lt;<span class="variable">$&#123;kv_dir_size&#125;</span>; ++n))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$&#123;optional&#125;</span> <span class="keyword">in</span></span><br><span class="line">            <span class="string">&quot;deploy&quot;</span>)</span><br><span class="line">                deploy_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ARBITER_RPC_PORT[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CARRIER_RPC_PORT[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;start&quot;</span>)</span><br><span class="line">                start_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;stop&quot;</span>)</span><br><span class="line">                stop_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;clean&quot;</span>)</span><br><span class="line">                clean_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;restart&quot;</span>)</span><br><span class="line">                stop_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                start_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;update&quot;</span>)</span><br><span class="line">                stop_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                deploy_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;ARBITER_RPC_PORT[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;CARRIER_RPC_PORT[n]&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;arbiter_addr_list&#125;</span>&quot;</span></span><br><span class="line">                ;;</span><br><span class="line">            <span class="string">&quot;status&quot;</span>)</span><br><span class="line">                status_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[n]&#125;</span>&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> 0</span><br><span class="line">                ;;</span><br><span class="line">            *)</span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;Usage: ./kv_tools.sh [deploy|start|stop|clean|restart|update|status]&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;deploy: 部署kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;start: 启动kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;stop: 停止kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;clean: 清理kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;restart: 重启kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;update: 更新kv&quot;</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;status: 查看kv状态&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> -1</span><br><span class="line">                ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;optional&#125;</span> == <span class="string">&quot;deploy&quot;</span> ]] || [[ <span class="variable">$&#123;optional&#125;</span> == <span class="string">&quot;update&quot;</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># 等待 kv 启动完成</span></span><br><span class="line">        <span class="built_in">sleep</span> 5</span><br><span class="line">        <span class="comment"># 查看 kv 状态</span></span><br><span class="line">        status_kv <span class="string">&quot;<span class="variable">$&#123;kv_root_dirs[0]&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">&quot;CirroEngine配置参数 client_arbiter_address_list: \e[1;32m<span class="variable">$&#123;arbiter_addr_list&#125;</span>\e[0m&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CirroData</category>
        <category>kv</category>
      </categories>
      <tags>
        <tag>kv</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接到CirroData-OLTP</title>
    <url>/2023/10/23/56/</url>
    <content><![CDATA[<h3 id="运行CirroData-OLTP">运行CirroData-OLTP</h3>
<p>确保CirroData-OLTP已经安装并在你的系统上运行。</p>
<h3 id="安装MySQL驱动程序-mysql-connector-python">安装MySQL驱动程序 <code>mysql-connector-python</code></h3>
<p>确保你的Python版本符合要求，并且可以在有网络环境（python最低要求为3.11版本）或无网络环境（python最低要求为2.7版本）下安装MySQL驱动程序。</p>
<h4 id="在有网络环境下安装：">在有网络环境下安装：</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install mysql-connector-python</span><br></pre></td></tr></table></figure>
<p>这将自动下载并安装最新版本的MySQL驱动程序。</p>
<h4 id="在无网络环境下安装：">在无网络环境下安装：</h4>
<ol>
<li>
<p>下载离线安装包 <a href="https://downloads.mysql.com/archives/get/p/29/file/mysql-connector-python-8.0.18.tar.gz">mysql-connector-python-8.0.18.tar.gz</a> 到你的系统中。</p>
</li>
<li>
<p>使用以下命令解压缩文件：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvfz mysql-connector-python-8.0.18.tar.gz</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>进入解压后的目录：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mysql-connector-python-8.0.18</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>执行以下命令进行安装，可以指定安装路径：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py install --prefix=/path/to/your/directory</span><br></pre></td></tr></table></figure>
<p><code>--prefix=/path/to/your/directory</code> 是可选项，用于指定你希望安装mysql-connector-python的路径。</p>
<h3 id="Python连接CirroData-OLTP示例">Python连接CirroData-OLTP示例</h3>
<p>以下是Python脚本示例，用于连接到CirroData-OLTP服务器并执行查询：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动安装mysql-connector-python且指定了安装路径则需要将安装路径添加到Python模块搜索路径,路径至少要精确到site-packages目录</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/path/to/your/directory/lib/python3.6/site-packages&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到MySQL服务器</span></span><br><span class="line">conn = mysql.connector.connect(</span><br><span class="line">    host=<span class="string">&#x27;127.0.0.1&#x27;</span>,   <span class="comment"># 连接名称，默认127.0.0.1</span></span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,        <span class="comment"># 用户名</span></span><br><span class="line">    passwd=<span class="string">&#x27;password&#x27;</span>,  <span class="comment"># 密码，若无密码删除改行</span></span><br><span class="line">    port=<span class="number">4486</span>,          <span class="comment"># 端口，默认为3306，修改为CirroData-OLTP配置的端口号</span></span><br><span class="line">    db=<span class="string">&#x27;test&#x27;</span>           <span class="comment"># 数据库名称</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标对象</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行SQL查询</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SHOW DATABASES;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检索查询结果</span></span><br><span class="line">results = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭游标和连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>确保按照脚本中的注释更改连接参数以匹配你的CirroData-OLTP配置。通过执行上述脚本，你可以连接到CirroData-OLTP服务器并执行查询。这个示例中的查询是 <code>SHOW DATABASES;</code>，你可以根据你的需要更改查询。</p>
<p>执行脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python show_databases.py</span><br></pre></td></tr></table></figure>
<p><img src="/images/python%E8%BF%9E%E6%8E%A5%E5%88%B0CirroData-OLTP/show_databases.png" alt=""></p>
<p>更多API介绍详见<a href="https://dev.mysql.com/doc/connector-python/en/connector-python-reference.html">Connector/Python API Reference</a></p>
]]></content>
      <categories>
        <category>CirroData-OLTP</category>
      </categories>
  </entry>
  <entry>
    <title>sit代码覆盖率</title>
    <url>/2023/04/28/07/</url>
    <content><![CDATA[<ol>
<li>编译coverage版本</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=coverage --pack_all=1 --pack_type=onebox all</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>搭建环境,配置参数<code>brpc_dsink_enable</code>需改为<code>false</code></p>
</li>
<li>
<p>进行sit</p>
</li>
<li>
<p>kill 行云进程号</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> <span class="variable">$&#123;pid&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>等待1分钟,查看是否生成*.gcda文件的时间是否在当前时间左右,若是则成功了建议命令,执行效率高</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lhR gcda/ | grep <span class="string">&quot;\.gcda$&quot;</span></span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find gcda/ -name <span class="string">&quot;*.gcda&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -lh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>将文件打包,并copy到代码执行编译的目录下</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar cjf gcda.tar.bz2 gcda/*</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>在编译路径下，执行report_coverage.sh脚本生成覆盖率报告（会生成coverage目录）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./report_coverage.sh -gcda=./gcda.tar.bz2 <span class="variable">$&#123;模块名1&#125;</span> <span class="variable">$&#123;模块名2&#125;</span> <span class="variable">$&#123;模块名...&#125;</span></span><br></pre></td></tr></table></figure>
<p>指定模块,则生成对应模块的覆盖率文件不指定模块,则生成整个项目的覆盖率文件</p>
<ol start="8">
<li>coverage/xcloud.report/下，执行命令</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 12345</span><br></pre></td></tr></table></figure>
<ol start="9">
<li>查看覆盖率在浏览器输入当前节点的IP:12345</li>
</ol>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>覆盖率</tag>
      </tags>
  </entry>
  <entry>
    <title>vimdiff使用介绍</title>
    <url>/2023/05/21/58/</url>
    <content><![CDATA[<h3 id="打开-vimdiff">打开 <code>vimdiff</code></h3>
<p>在终端中输入以下命令即可打开 <code>vimdiff</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vimdiff file1.txt file2.txt</span><br></pre></td></tr></table></figure>
<p>其中 <code>file1.txt</code> 和 <code>file2.txt</code> 是要进行比较的两个文件的路径。</p>
<h3 id="比较文件">比较文件</h3>
<p>打开 <code>vimdiff</code> 后，您将会看到两个窗口，每个窗口显示一个文件。所有的差异都会被突出显示。您可以通过按 <code>Ctrl+w</code> 然后再按 <code>w</code> 键来在窗口之间切换。</p>
<h3 id="导航差异">导航差异</h3>
<p>您可以使用 <code>vim</code> 的标准导航命令来浏览差异，例如：</p>
<ul>
<li>使用 <code>j</code> 和 <code>k</code> 键在差异之间上下移动</li>
<li>使用 <code>h</code> 和 <code>l</code> 键在两个文件之间左右移动</li>
</ul>
<h3 id="解决差异">解决差异</h3>
<ul>
<li>使用<code>:diffget</code>命令会将光标所在行差异,从非光标所在窗口复制到光标所在窗口相应的位置上</li>
<li>使用<code>:diffput</code>命令会将光标所在行差异,从光标所在窗口复制到非光标所在窗口相应的位置上</li>
</ul>
<p>可以使用行范围来指定要合并的代码块例如：<code>:2,5diffget</code> 将从光标所在窗口的第2行到第5行的文本复制到左侧窗口中的相应位置上例如：<code>:2,5diffput</code> 将从光标所在窗口的第2行到第5行的文本复制到右侧窗口中的相应位置上</p>
<h3 id="重新加载文件并进行新的比较">重新加载文件并进行新的比较</h3>
<p>使用 <code>:diffupdate</code> 命令重新加载文件并进行新的比较</p>
<h3 id="保存并退出">保存并退出</h3>
<p>完成差异解决后，使用以下命令即可保存更改并退出 <code>vimdiff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wqa</span><br></pre></td></tr></table></figure>
<h3 id="vimdiff常用快捷键">vimdiff常用快捷键</h3>
<p>前提光标位于左侧窗口</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>在窗口之间切换</td>
<td><code>Ctrl+w</code> <code>w</code></td>
</tr>
<tr>
<td>跳转到下一个差异</td>
<td><code>]c</code></td>
</tr>
<tr>
<td>跳转到上一个差异</td>
<td><code>[c</code></td>
</tr>
<tr>
<td>将差异从左侧复制到右侧</td>
<td><code>do</code></td>
</tr>
<tr>
<td>将差异从右侧复制到左侧</td>
<td><code>dp</code></td>
</tr>
<tr>
<td>打开折叠</td>
<td><code>zo</code></td>
</tr>
<tr>
<td>关闭折叠</td>
<td><code>zc</code></td>
</tr>
<tr>
<td>打开所有折叠</td>
<td><code>zR</code></td>
</tr>
<tr>
<td>关闭所有折叠</td>
<td><code>zM</code></td>
</tr>
<tr>
<td>重新加载文件并更新比较结果</td>
<td><code>Ctrl+L</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>vimdiff</category>
      </categories>
      <tags>
        <tag>vimdiff</tag>
      </tags>
  </entry>
  <entry>
    <title>动态参数</title>
    <url>/2022/07/19/49/</url>
    <content><![CDATA[<h3 id="配置参数">配置参数</h3>
<div class="tabs" id="dynamic-parameter"><ul class="nav-tabs"><li class="tab active"><a href="#dynamic-parameter-1">3.0</a></li><li class="tab"><a href="#dynamic-parameter-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dynamic-parameter-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>parameter_setting_sync_timeout</td>
<td>动态参数设定的同步超时时间.如果超时,则不再等待其他节点的同步状态,可能导致其他节点使用的参数不是最新值.</td>
<td>int32</td>
<td>5</td>
<td><div style="white-space: nowrap">[1, 100]</div></td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="dynamic-parameter-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>param_update_timeout</td>
<td>参数修改指令单个节点超时时间，单位s.</td>
<td>int32</td>
<td>5</td>
<td>[1, 100]</td>
</tr>
</tbody>
</table></div></div></div>
<h4 id="该配置参数的作用">该配置参数的作用</h4>
<ol>
<li>节点同步修改超时时间,若超时节点同步失败</li>
<li>sql下发节点,每次获取节点同步回报信息失败后等待0.5秒后重试,若一直获取失败，则总重试等待时间为 <code>节点数 × parameter_setting_sync_timeout</code></li>
</ol>
<div class="note warning"><h3 id="警告">警告</h3>
<p>节点数 × parameter_setting_sync_timeout ≠ 总同步超时时间<br>总同步超时时间 = 节点数 × parameter_setting_sync_timeout / 0.5 * 获取节点同步回报信息耗时 + 节点数 × parameter_setting_sync_timeout</p>
</div>
<h3 id="目前支持修改的参数">目前支持修改的参数</h3>
<div class="tabs" id="version"><ul class="nav-tabs"><li class="tab active"><a href="#version-1">3.0版</a></li><li class="tab"><a href="#version-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="version-1"><div class="tabs" id="dynamic_parameter_3.0"><ul class="nav-tabs"><li class="tab active"><a href="#dynamic_parameter_3.0-1">DB级别参数</a></li><li class="tab"><a href="#dynamic_parameter_3.0-2">PC级别参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dynamic_parameter_3.0-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>page_compress_algorithm</td>
<td>页数据压缩算法</td>
<td>string</td>
<td>SNAPPY</td>
<td>{SNAPPY,LZ4,ZSTD}</td>
</tr>
<tr>
<td>cirrofile_max_size</td>
<td>单个cirrofile文件的大小上限</td>
<td>int64</td>
<td>1GB</td>
<td>[256MB, 4GB]</td>
</tr>
<tr>
<td>cirrofile_max_row</td>
<td>单个cirrofile文件的最大行数</td>
<td>int64</td>
<td>10485760</td>
<td><div style="white-space: nowrap">[10000000, 100000000]</div></td>
</tr>
<tr>
<td>dictionary_page_num</td>
<td>字典编码中，字典的页数量字典达到记录数和大小中任何一个条件后，不能继续新增字典记录。</td>
<td>int32</td>
<td>4</td>
<td>[1, 4]</td>
</tr>
<tr>
<td>cirrofile_reserve_rate</td>
<td>cirrofile文件的预留空间比例，以防止实际产生的cirrofile文件超过设定的大小。</td>
<td>double</td>
<td>0.1</td>
<td>[0.01, 0.2]</td>
</tr>
<tr>
<td>page_compress_optimize_enable</td>
<td>是否启用页压缩优化。启用后，数据文件将无法兼容标准parquet格式。</td>
<td>bool</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>page_compress_optimize_threshold_ratio</td>
<td>页压缩优化的数据压缩率阈值。如果启用页压缩优化，则数据压缩率超过该百分比，才进行页数据压缩存储。该参数只对新增数据有效。该参数只在页压缩优化启用时有效。启用后，数据无法兼容标准parquet格式。</td>
<td>double</td>
<td>0.6</td>
<td>(0, 1]</td>
</tr>
<tr>
<td>dictionary_item_num</td>
<td>字典编码中，字典的记录数量。字典达到记录数和大小中任何一个条件后，不能继续新增字典记录。</td>
<td>int32</td>
<td>65535</td>
<td>[32768, 65535]</td>
</tr>
<tr>
<td>plain_encoding_rule</td>
<td>指定不适用编码的数据类型，多个类型之间用逗号’,'分隔。主要用于数据加载时的编码过程控制。</td>
<td>string</td>
<td></td>
<td></td>
</tr>
<tr>
<td>page_rownum_index_enable</td>
<td>是否在加载数据时，创建page-row索引。</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>page_maxmin_index_enable</td>
<td>是否在加载数据时，创建page内部极值索引。</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="dynamic_parameter_3.0-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>dml_write_buffer_mdp_num</td>
<td>表更新、有序表加载时，用于数据写入的缓存MDP数量。</td>
<td>int32</td>
<td>3</td>
<td>[1, 5]</td>
</tr>
<tr>
<td>default_timestamp_format</td>
<td>timestamp的默认格式。csv加载和cast时会按照此参数将字符串类型与timestamp类型进行转换。可根据需要调整分隔符与年月日时分秒的位置。</td>
<td>string</td>
<td><div style="white-space: nowrap">yyyy-mm-dd hh24:mi:ss.ff</div></td>
<td></td>
</tr>
<tr>
<td>default_date_format</td>
<td>Date类型默认格式,csv加载和cast时会按照此参数将字符串类型与date类型进行转换。可根据需要调整分隔符与年月日时分秒的位置。</td>
<td>string</td>
<td>yyyy/mm/dd hh24:mi:ss</td>
<td></td>
</tr>
<tr>
<td>compaction_group_num</td>
<td>Compaction任务中，分组的数量。需要整并的数据文件不小于该值时，整并结果的数据文件数量不少于该值。</td>
<td>int32</td>
<td>1</td>
<td>[1, 16]</td>
</tr>
<tr>
<td>compaction_max_file_size</td>
<td>Compaction任务中，判定为不需要整并的数据文件的大小阈值。比阈值小的文件，都需要进行整并。</td>
<td>int64</td>
<td>849346560</td>
<td>[100MB, 1GB]</td>
</tr>
<tr>
<td>local_data_cache_policy</td>
<td>本地数据缓存缓存策略.<br>NO_CACHE: 不进行本地缓存;<br> AUTO_CACHE: 自动选择节点进行缓存（最多选择两个）;<br>GLOBAL_CACHE: 所有节点都可以缓存.</td>
<td>string</td>
<td>AUTO_CACHE</td>
<td>NO_CACHE, AUTO_CACHE, GLOBAL_CACHE</td>
</tr>
</tbody>
</table></div></div></div></div><div class="tab-pane" id="version-2"><div class="tabs" id="dynamic_parameter_old"><ul class="nav-tabs"><li class="tab active"><a href="#dynamic_parameter_old-1">DB级别参数</a></li><li class="tab"><a href="#dynamic_parameter_old-2">PC级别参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dynamic_parameter_old-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>page_compress_type</td>
<td>Page数据压缩算法: 1-SNAPPY, 2-LZ4;<em><strong>如果使用非SNAPPY算法，会影响与标准parquet格式的兼容</strong></em></td>
<td>int32</td>
<td>1</td>
<td>{1,2}</td>
</tr>
<tr>
<td>datapack_maxsize</td>
<td>单个DataPack文件大小上限，单位Byte</td>
<td>int64</td>
<td>1073741824</td>
<td><div style="white-space: nowrap">[2<sup>23</sup>, 2<sup>63</sup>-1]</div></td>
</tr>
<tr>
<td>datapack_maxrownum</td>
<td>单个DataPack文件数据行数上限</td>
<td>int64</td>
<td>10485760</td>
<td>[1, 2<sup>63</sup>-1]</td>
</tr>
<tr>
<td>dictpage_num</td>
<td>ColumnChunk中字典页的缓存页数</td>
<td>int32</td>
<td>4</td>
<td>[1, 4]</td>
</tr>
<tr>
<td>filesize_reserverate</td>
<td>[Percentage]DP文件中实际使用空间百分比，取值范围80~99</td>
<td>int32</td>
<td>90</td>
<td>[80, 99]</td>
</tr>
<tr>
<td>no_page_compress_optimize</td>
<td>是否禁止Page压缩优化; 如果不禁止，会影响与标准parquet格式的兼容</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>compress_validrate</td>
<td>[Percentage]DP文件数据压缩百分比阈值，取值范围1~100，压缩后与压缩前大小比例超过该值才进行压缩</td>
<td>int32</td>
<td>60</td>
<td>[1, 100]</td>
</tr>
<tr>
<td>dictcardinality</td>
<td>字典编码中，字典条目上限</td>
<td>int32</td>
<td>65535</td>
<td>(0, 2<sup>31</sup>-1]</td>
</tr>
<tr>
<td>plain_encoding_rule</td>
<td>默认Plain编码规则，多个类型用’，'分隔. 具体参考Release Note</td>
<td>string</td>
<td></td>
<td></td>
</tr>
<tr>
<td>page_rownum_index</td>
<td>是否在加载数据时，创建page-row索引</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>page_max_min_index</td>
<td>是否在加载数据时，创建page内部极值索引</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="dynamic_parameter_old-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>write_buffer_num</td>
<td>异步加载线程使用的缓存块数</td>
<td>int32</td>
<td>3</td>
<td>[1, 5]</td>
</tr>
<tr>
<td>cast_timestamp_format</td>
<td><Basic>Timestamp类型默认格式，小数精度为9</td>
<td>string</td>
<td><div style="white-space: nowrap">yyyy-mm-dd hh24:mi:ss.ff</div></td>
<td></td>
</tr>
<tr>
<td>cast_date_format</td>
<td>Date类型默认格式,csv加载和cast时会按照此参数将字符串类型与date类型进行转换。可根据需要调整分隔符与年月日时分秒的位置。</td>
<td>string</td>
<td>yyyy/mm/dd hh24:mi:ss</td>
<td></td>
</tr>
<tr>
<td>compact_group_num</td>
<td>整并分组数</td>
<td>int32</td>
<td>1</td>
<td>[1, 64]</td>
</tr>
<tr>
<td>compact_filesize_threshold</td>
<td>不参加整并的文件大小下限，单位BYTE</td>
<td>int64</td>
<td>849346560</td>
<td><div style="white-space: nowrap">[0, 2<sup>63</sup>-1]</div></td>
</tr>
</tbody>
</table></div></div></div></div></div></div>
<h3 id="参数值生效优先级">参数值生效优先级</h3>
<p>PC 级别参数 &gt; DB 级别参数 &gt; 集群级别参数（ds.xml）</p>
<h3 id="系统表">系统表</h3>
<div class="tabs" id="system_table"><ul class="nav-tabs"><li class="tab active"><a href="#system_table-1">V$CLUSTER_PARAMETERS_INFO</a></li><li class="tab"><a href="#system_table-2">V$DB_PARAMETERS_INFO</a></li></ul><div class="tab-content"><div class="tab-pane active" id="system_table-1"><p>systemadmin 用户查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> V$CLUSTER_PARAMETERS_INFO;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="system_table-2"><p>system 用户查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> V$DB_PARAMETERS_INFO;</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="修改动态参数SQL">修改动态参数SQL</h3>
<div class="tabs" id="修改动态参数"><ul class="nav-tabs"><li class="tab active"><a href="#修改动态参数-1">设置 DB 级别参数</a></li><li class="tab"><a href="#修改动态参数-2">设置 PC 级别参数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="修改动态参数-1"><p>systemadmin用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE db_name <span class="keyword">SET</span> <span class="keyword">PARAMETER</span> parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>system用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> PARAM <span class="keyword">SET</span> parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="修改动态参数-2"><p>system用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> PC PARAM <span class="keyword">SET</span> pc_name.parameter_name <span class="operator">=</span> <span class="string">&#x27;parameter_value&#x27;</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<h3 id="修改信息存放路径">修改信息存放路径</h3>
<p>参数修改信息存放在zookeeper上</p>
<ul>
<li>dp级参数存放路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/xcloud_name/cluster_name/XCLOUD/PUCONTROLLER/PARAMETERLIST/db_id/SYSPFILE</span><br></pre></td></tr></table></figure>
<ul>
<li>pc级参数存放路径</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/xcloud_name/cluster_name/XCLOUD/PUCONTROLLER/DB_LIST/db_id/PC_LIST/pc_name/PARAMETERLIST/PCPFILE</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>动态参数</tag>
      </tags>
  </entry>
  <entry>
    <title>句柄缓存</title>
    <url>/2022/08/01/38/</url>
    <content><![CDATA[<h3 id="配置参数">配置参数</h3>
<div class="tabs" id="handle-cache"><ul class="nav-tabs"><li class="tab active"><a href="#handle-cache-1">3.0</a></li><li class="tab"><a href="#handle-cache-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="handle-cache-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_handle_cache_bucket_num</td>
<td>文件句柄缓存使用的分桶数量,用于减少并发时的冲突.</td>
<td>int32</td>
<td>64</td>
<td>[4, 256]</td>
</tr>
<tr>
<td>file_handle_cache_enable</td>
<td>文件句柄缓存开关,设置是否使用文件句柄缓存.</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>file_handle_cache_num</td>
<td>文件句柄缓存最大可缓存的文件句柄的数量.file_handle_cache_enable为true时有效.</td>
<td>int32</td>
<td>100000</td>
<td>[10000, 1000000]</td>
</tr>
<tr>
<td>file_handle_cache_swapout_timeout</td>
<td>文件句柄缓存中未被使用的句柄最长可保留的时间.</td>
<td>int64</td>
<td>21600</td>
<td>[1h, 1d]</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="handle-cache-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>num_file_handle_cache_partitions</td>
<td>文件句柄缓存使用的分区数量（用于将句柄缓存拆成多个分区）.</td>
<td>uint64</td>
<td>16</td>
<td>[1, uint64_max]</td>
</tr>
<tr>
<td>cache_file_handle</td>
<td>文件句柄缓存开关,设置是否使用文件句柄缓存.</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>max_cached_file_handles</td>
<td>文文件句柄缓存最大可缓存的文件句柄的数量.</td>
<td>uint64</td>
<td>20000</td>
<td>[0, uint64_max]</td>
</tr>
<tr>
<td>unused_file_handle_timeout_sec</td>
<td>文件句柄缓存中未被使用的句柄最长可保留的时间(秒).</td>
<td>uint64</td>
<td>21600</td>
<td>[0, uint64_max]</td>
</tr>
</tbody>
</table></div></div></div>
<h3 id="适用范围">适用范围</h3>
<ol>
<li>只读文件</li>
<li>短期内不会修改的文件</li>
</ol>
]]></content>
      <categories>
        <category>CirroData</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>句柄缓存</tag>
        <tag>句柄</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过hadoop访问s3存储桶</title>
    <url>/2023/05/30/12/</url>
    <content><![CDATA[<h2 id="在s3a配置文件所在目录下创建脚本文件并添加可执行权限">在s3a配置文件所在目录下创建脚本文件并添加可执行权限</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch set_s3a_classpath.sh</span><br><span class="line">chomod +x set_s3a_classpath.sh</span><br></pre></td></tr></table></figure>
<h2 id="复制以下内容到set-s3a-classpath-sh脚本文件中">复制以下内容到<code>set_s3a_classpath.sh</code>脚本文件中</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -euo pipefail</span><br><span class="line">error_flag=0</span><br><span class="line">hadoop_conf_dir=$(pwd)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查并复制核心配置文件</span></span><br><span class="line">s3a_core_file_path=$(find &quot;$hadoop_conf_dir&quot; -name &quot;*core-site.xml&quot; | head -n 1)</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$s3a_core_file_path&quot; ]; then</span><br><span class="line">    if [ ! -e &quot;$hadoop_conf_dir/core-site.xml&quot; ]; then</span><br><span class="line">        cp &quot;$s3a_core_file_path&quot; &quot;$hadoop_conf_dir/core-site.xml&quot;</span><br><span class="line">    fi</span><br><span class="line">else</span><br><span class="line">    echo &quot;找不到配置文件&quot;</span><br><span class="line">    error_flag=1</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取Hadoop版本信息</span></span><br><span class="line">hadoop_version=$(hadoop version | head -n 1 | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">echo &quot;Hadoop版本为: $hadoop_version&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断版本是否为CDH</span></span><br><span class="line">if [[ &quot;$hadoop_version&quot; != *&quot;-cdh&quot;* ]]; then</span><br><span class="line">    # 查找Hadoop安装目录</span><br><span class="line">    hadoop_bin=$(hadoop version | tail -n 1 | awk &#x27;&#123;print $6&#125;&#x27;)</span><br><span class="line">    if [ -z &quot;$hadoop_bin&quot; ]; then</span><br><span class="line">        echo &quot;未找到Hadoop安装目录.&quot;</span><br><span class="line">        error_flag=1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    hadoop_dir=$(dirname &quot;$(dirname &quot;$hadoop_bin&quot;)&quot;)</span><br><span class="line"></span><br><span class="line">    # 查找包含S3AFileSystem类的JAR文件</span><br><span class="line">    if [ -d &quot;$hadoop_dir&quot; ]; then</span><br><span class="line">        s3a_jar_sdk_path=$(find &quot;$hadoop_dir&quot; -name &quot;aws-java-sdk-bundle-*.jar&quot; | head -n 1)</span><br><span class="line">        s3a_jar_path=$(find &quot;$hadoop_dir&quot; -name &quot;hadoop-aws*.jar&quot; | head -n 1)</span><br><span class="line"></span><br><span class="line">        if [ -z &quot;$s3a_jar_sdk_path&quot; ]; then</span><br><span class="line">            echo &quot;未找到S3A JAR文件.&quot;</span><br><span class="line">            error_flag=1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ -z &quot;$s3a_jar_path&quot; ]; then</span><br><span class="line">            echo &quot;未找到S3A JAR文件.&quot;</span><br><span class="line">            error_flag=1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $error_flag -eq 0 ]; then</span><br><span class="line">            echo &quot;找到S3A JAR文件: $s3a_jar_sdk_path&quot;</span><br><span class="line">            export HADOOP_CLASSPATH=$(hadoop classpath):&quot;$s3a_jar_sdk_path&quot;</span><br><span class="line"></span><br><span class="line">            echo &quot;找到S3A JAR文件: $s3a_jar_path&quot;</span><br><span class="line">            export HADOOP_CLASSPATH=$(hadoop classpath):&quot;$s3a_jar_path&quot;</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $error_flag -eq 0 ]; then</span><br><span class="line">    # 生成log4j.properties文件</span><br><span class="line">    log4j_file=&quot;$hadoop_conf_dir/log4j.properties&quot;</span><br><span class="line"></span><br><span class="line">    if [ ! -e &quot;$log4j_file&quot; ]; then</span><br><span class="line">        echo &quot;# 全局日志配置&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.rootLogger=ERROR, console&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;# 控制台appender配置&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.appender.console=org.apache.log4j.ConsoleAppender&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.appender.console.target=System.err&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.appender.console.layout=org.apache.log4j.PatternLayout&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.appender.console.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;# Hadoop S3AFileSystem日志配置&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line">        echo &quot;log4j.logger.org.apache.hadoop.fs.s3a.S3AFileSystem=ERROR&quot; &gt;&gt;&quot;$log4j_file&quot;</span><br><span class="line"></span><br><span class="line">        echo &quot;生成log4j.properties文件: $log4j_file&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    # 设置HADOOP_CONF_DIR为包含core-site.xml的目录</span><br><span class="line">    export HADOOP_CONF_DIR=&quot;$hadoop_conf_dir&quot;</span><br><span class="line">    echo &quot;添加环境变量完成.&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="执行脚本-以设置环境变量">执行脚本,以设置环境变量</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. set_s3a_classpath.sh</span><br></pre></td></tr></table></figure>
<h2 id="访问s3存储桶">访问s3存储桶</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop fs -<span class="built_in">ls</span> s3a://&lt;bucket_name&gt;/</span><br></pre></td></tr></table></figure>
<p>如果您想屏蔽Hadoop中的日志，可以通过更改Hadoop的日志级别来实现。以下是一些步骤，可以帮助您完成这个任务：</p>
<ol>
<li>
<p>找到Hadoop的日志配置文件，<code>log4j.properties</code></p>
</li>
<li>
<p>打开日志配置文件，找到与S3A相关的日志记录器。在这个文件中，您可能会看到一些类似<code>log4j.logger.org.apache.hadoop.fs.s3a.S3AFileSystem=DEBUG</code>的行，这些行指定了日志级别。</p>
</li>
<li>
<p>将日志级别调整为您想要的级别。常见的级别包括：</p>
<ul>
<li><code>OFF</code>：完全关闭日志记录。</li>
<li><code>FATAL</code>：仅记录严重错误。</li>
<li><code>ERROR</code>：记录错误信息。</li>
<li><code>WARN</code>：记录警告和错误信息。</li>
<li><code>INFO</code>：记录一般信息、警告和错误信息。</li>
<li><code>DEBUG</code>：记录详细的调试信息。</li>
</ul>
<p>如果您只想屏蔽S3A的日志，可以将对应的日志记录器级别设置为<code>OFF</code>。</p>
</li>
<li>
<p>保存并关闭日志配置文件。</p>
</li>
</ol>
<p>以下是一个示例的log4j.properties文件，用于访问S3并屏蔽日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=ERROR, console</span><br><span class="line"></span><br><span class="line"># Console appender configuration</span><br><span class="line">log4j.appender.console=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target=System.err</span><br><span class="line">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line"># Hadoop S3AFileSystem logger configuration</span><br><span class="line">log4j.logger.org.apache.hadoop.fs.s3a.S3AFileSystem=ERROR</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>s3</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>s3</tag>
      </tags>
  </entry>
  <entry>
    <title>小数据量回归测试</title>
    <url>/2022/07/13/47/</url>
    <content><![CDATA[<div class="note warning"><h3 id="仅适用于3-0之前的版本">仅适用于3.0之前的版本</h3>
</div>
<h4 id="修改配置">修改配置</h4>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>kerb_cross_realm_conf</td>
<td>/mnt/disk2/external_linux_csv/krb5.conf</td>
<td>远程连接带kerberos集群需要的krb5.conf配置文件</td>
</tr>
<tr>
<td>use_combination</td>
<td>true</td>
<td>是否支持组合型sql:create table as</td>
</tr>
<tr>
<td>check_storage_exceeded</td>
<td>false</td>
<td>是否开启存储空间限制检查(开启可能会导致inster失败)</td>
</tr>
</tbody>
</table>
<h4 id="autotest必要前提">autotest必要前提</h4>
<p>修改<code>systemadmin</code>的密码为<code>123456_</code></p>
<h4 id="基础表加载">基础表加载</h4>
<p>用例模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.16.12.45/afe/#tab_id=view_job&amp;object_id=142460</span><br></pre></td></tr></table></figure>
<h4 id="小数据量double环境测试">小数据量double环境测试</h4>
<p>需要修改ip、端口、数据库、用户和testjdbc<br>
用例模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.16.12.45/afe/#tab_id=view_job&amp;object_id=142217</span><br></pre></td></tr></table></figure>
<h4 id="小数据量number环境测试">小数据量number环境测试</h4>
<p>参数配置</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>integer_div_as_number_enable</td>
<td>true</td>
<td>整数除法结果类型是否设置为NUMBER类型</td>
</tr>
<tr>
<td>constant_floating_as_number_enable</td>
<td>true</td>
<td>浮点数常量是否为NUMBER类型</td>
</tr>
</tbody>
</table>
<p>需要修改ip、端口、数据库、用户和testjdbc<br>
用例模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://172.16.12.45/afe/#tab_id=view_job&amp;object_id=139306</span><br></pre></td></tr></table></figure>
<h4 id="48公共环境配置">48公共环境配置</h4>
<p>注意:借公共环境时，不要借44.54节点，该节点没有安装cgroups,无法启动3.0</p>
<h4 id="HDFSMetaQueryProxy配置">HDFSMetaQueryProxy配置</h4>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>keyTabFile</td>
<td>/home/cirrofs/cirrofs_cfs/key/cirrofs.keytab</td>
</tr>
<tr>
<td>userPrincipal</td>
<td>cirrofs/_HOST@BONC4.COM</td>
</tr>
</tbody>
</table>
<h4 id="xcloud配置">xcloud配置</h4>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>kerb_principal</td>
<td>cirrofs/_HOST@BONC4.COM</td>
</tr>
<tr>
<td>kerb_keytab_file</td>
<td>/home/cirrofs/cirrofs_cfs/key/cirrofs.keytab</td>
</tr>
<tr>
<td>hadoop_user</td>
<td>cirrofs</td>
</tr>
</tbody>
</table>
<h4 id="曾遇问题">曾遇问题</h4>
<table>
<thead>
<tr>
<th>报错信息</th>
<th>说明</th>
<th>处理方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unhandled ImportError: No module named pandas</td>
<td>auto test 选择的host节点存在问题</td>
<td>更换节点</td>
</tr>
<tr>
<td>HDFSMetaQueryProxy::init error</td>
<td>helper版本导致</td>
<td>xcloud的配置参数helper_version设置为0 或使用3.0.0版helper</td>
</tr>
<tr>
<td>KerberosAuthException: failure to login</td>
<td>kerb相关配置不对</td>
<td>修改配置</td>
</tr>
</tbody>
</table>
<p>详见<a href="https://doc.weixin.qq.com/doc/w3_AHAAuwaoAMAFGOjox3pTWCkCFoVjS?scode=AHEAaQdHAAcAZOt6VSAJMA4gaCAME">小数据量测试介绍</a></p>
<h4 id="auto-test配置">auto test配置</h4>
<table>
<thead>
<tr>
<th>目的</th>
<th>修改</th>
</tr>
</thead>
<tbody>
<tr>
<td>关闭并发</td>
<td>parallel=False</td>
</tr>
<tr>
<td>sql都从入口节点下发</td>
<td>test_jdbc=“XCloud_TestJDBC_SP_connectDirectTrue.jar”</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>小数据量</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>总结 CirroData 开发中曾遇到的问题的处理方法</title>
    <url>/2022/07/19/18/</url>
    <content><![CDATA[<h2 id="基础知识">基础知识</h2>
<h3 id="std-map">std::map</h3>
<p>下标访问，若元素不存在会导致新增该元素使用成员函数erase()后，切记不可使用下标访问</p>
<h3 id="static">static</h3>
<p>static变量是指静态的变量，不管是在全局还是局部声明的static变量都存放于程序的全局变量区域，所以它的生命周期是从程序开始到程序结束。但是static变量的作用域并不等同于它的生存周期，它的作用域决定于它被定义的位置。可以认为static变量的作用域&lt;=生存周期</p>
<h2 id="行云编译相关">行云编译相关</h2>
<h3 id="序列化">序列化</h3>
<p>增加成员，对应proto文件也要添加文件路径： be/src/proto/xxxx.proto</p>
<blockquote>
<p>注意：需要清三方库，否则编译会报错</p>
</blockquote>
<h3 id="编译报错">编译报错</h3>
<p>报错: make[1]: *** No rule to make target `be/src/idl/all’. Stop.<br>
编译命令后加上 idl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=release idl</span><br></pre></td></tr></table></figure>
<h2 id="行云打包">行云打包</h2>
<h3 id="跳过参数检查，适用于当前代码中配置参数与远端有不一致的情况">跳过参数检查，适用于当前代码中配置参数与远端有不一致的情况</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=release --pack_all=1 --strip-debug --test-flags-checking all</span><br></pre></td></tr></table></figure>
<h3 id="仅生成CirroEngine与CirroKV安装包">仅生成CirroEngine与CirroKV安装包</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=release --pack_all=1 all</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=release --pack_deploy=1 all</span><br></pre></td></tr></table></figure>
<h3 id="生成CEA安装包，包括CirroEngine-RegistrationCenter-MetaProxy-CirroKV">生成CEA安装包，包括CirroEngine,RegistrationCenter,MetaProxy,CirroKV</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./build.sh --build=release --pack_deploy=2 all</span><br></pre></td></tr></table></figure>
<h2 id="访问zookeeper">访问zookeeper</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/zkCli.sh -server <span class="variable">$&#123;ip&#125;</span>:<span class="variable">$&#123;port&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="公共环境使用hdfs">公共环境使用hdfs</h2>
<ol>
<li>获取kerberos认证文件路径[kerb_keytab_file]</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -aA10 <span class="string">&quot;keytab&quot;</span> conf/ds.xml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看keytab文件中的帐号列表,获取当前节点[kerb_principal]</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">klist -ket /home/cirrofs/cirrofs_cfs/key/cirrofs.keytab</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>注册</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kinit -kt [kerb_keytab_file] [kerb_principal]</span><br></pre></td></tr></table></figure>
<p>例如：172.16.44.53节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kinit -kt /home/cirrofs/cirrofs_cfs/key/cirrofs.keytab cirrofs/hdp53.bonc.com@BONC4.COM</span><br></pre></td></tr></table></figure>
<h2 id="hadoop-配置文件路径">hadoop 配置文件路径</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> conf/config-env.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$HADOOP_HOME</span>/etc/hadoop/</span><br></pre></td></tr></table></figure>
<h2 id="查看hdfs磁盘使用情况">查看hdfs磁盘使用情况</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs dfs -<span class="built_in">du</span> -h /</span><br></pre></td></tr></table></figure>
<h2 id="查看HDFS中的数据是否损坏">查看HDFS中的数据是否损坏</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdfs fsck /path/to/file_or_directory -files -blocks -locations</span><br></pre></td></tr></table></figure>
<h3 id="CirroEngine下conf配置目录注意事项">CirroEngine下conf配置目录注意事项</h3>
<p>conf目录下不能添加hadoop同名配置文件,否则会导致默认hdfs连接使用conf目录下的配置文件,引发启动失败</p>
<h3 id="sql下发过程">sql下发过程</h3>
<p>SQLDeveloper --&gt; session --&gt; 计划 --&gt; node</p>
<h3 id="git开启push前不做检查开关">git开启push前不做检查开关</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin BugFix/gyf/42710 <span class="string">&#x27;--push-option=--no-ticket-check&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="redmine-楼层倒排">redmine 楼层倒排</h3>
<ol>
<li>点击右上角<code>我的账号</code></li>
<li><code>首选项</code>中<code>显示注释</code>，更改为<code>按时间顺序（倒序）</code></li>
</ol>
<h3 id="报错unbound-variable">报错<code>unbound variable</code></h3>
<p>shell脚本中有未声明的变量</p>
<p>在 shell 脚本中，默认情况下，如果使用了未声明的变量，脚本不会报错，而是会将该变量视为空字符串。这可能会导致脚本在运行过程中出现意外的结果或错误。若想开启对未声明变量的报错提示,可以在脚本开头添加以下行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -o nounset</span><br></pre></td></tr></table></figure>
<p>或者简写为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> -u</span><br></pre></td></tr></table></figure>
<h3 id="SQL字符串中包含单引号">SQL字符串中包含单引号</h3>
<p>为了避免单引号被解析为末尾的单引号，可以使用双单引号 ‘’ 代替单引号 ’</p>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>本地数据缓存</title>
    <url>/2022/07/19/52/</url>
    <content><![CDATA[<h2 id="各单号">各单号</h2>
<table>
<thead>
<tr>
<th>主题</th>
<th>单号</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据缓存需求</td>
<td>31501</td>
</tr>
<tr>
<td>数据缓存测试大纲</td>
<td>32428</td>
</tr>
<tr>
<td>数据缓存sit</td>
<td>36740</td>
</tr>
<tr>
<td>数据缓存优化需求</td>
<td>36258</td>
</tr>
<tr>
<td>数据缓存优化sit</td>
<td>37616</td>
</tr>
</tbody>
</table>
<h2 id="配置参数">配置参数</h2>
<h3 id="数据缓存">数据缓存</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>local_data_cache_dir</td>
<td>配置缓存数据的存储目录的绝对路径和每个目录的容量大小的字符串,不同路径使用英文逗号隔开,使用英文冒号分割路径和容量大小,例如: data/0,/data/1:1TB.代表缓存最大2TB,/data/0 和 /data/1分别最大1TB. 请注意,主机上每个CirroData进程必须有唯一的数据缓存目录.默认为空,代表禁用.</td>
<td>string</td>
<td>空</td>
<td>目录: 为空或存储目录数量大于等于1；容量: [4KB,4TB]（支持使用单位: K、KB、M、MB、G、GB、T、TB、P、PB、E、EB, 无单位默认为Byte,但要保证单位转换后的结果在取值范围内）</td>
</tr>
<tr>
<td>local_data_cache_enable</td>
<td>是否为远程读开启数据缓存.若需要启用数据缓存,则同时需要配置local_data_cache_dir参数.</td>
<td>bool</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>local_data_cache_file_max_size</td>
<td>缓存文件在停止追加数据前可以增加到的最大值,<mark>不等于缓存文件最终大小</mark>,建议与配置的缓存存储目录空间大小保持一致.</td>
<td>string</td>
<td>1099511627776</td>
<td>[4KB,4TB]</td>
</tr>
<tr>
<td>local_data_cache_max_file_num</td>
<td>允许打开的最大文件数,不能小于指定数据缓存目录的数量.若有两个存储目录,则每个存储目录下最大可打开文件数为n/2.</td>
<td>int32</td>
<td>1000</td>
<td>[数据缓存存储目录个数,int32_max]</td>
</tr>
<tr>
<td>local_data_cache_write_thread_num</td>
<td>每个数据缓存目录允许插入数据的并发线程数.</td>
<td>int32</td>
<td>1</td>
<td>(0,int32_max]</td>
</tr>
</tbody>
</table>
<div class="note warning"><h4 id="注意">注意</h4>
<p>若数据长度大于<code>local_data_cache_file_max_size</code>,则数据不会被缓存,数据缓存不支持拆分数据以存下超量数据</p>
</div>
<h3 id="数据缓存优化">数据缓存优化</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>consistent_hashing_min_virtual_node_count</td>
<td>数据缓存节点选择时一致性哈希的最小虚拟节点数.</td>
<td>int32</td>
<td>1000</td>
<td>(0,5000)</td>
</tr>
<tr>
<td>local_data_cache_policy</td>
<td>本地数据缓存策略.NO_CACHE: 不进行本地缓存 AUTO_CACHE: 自动选择节点进行缓存（最多选择两个） GLOBAL_CACHE: 所有节点都可以缓存, 属于动态参数</td>
<td>string</td>
<td>auto_cache</td>
<td>no_cache,<br>auto_cache,<br>global_cache</td>
</tr>
</tbody>
</table>
<h2 id="数据缓存规则">数据缓存规则</h2>
<h3 id="缓存文件缓存数据规则">缓存文件缓存数据规则</h3>
<ol>
<li>最新的缓存文件file_1不足以存放新数据data1时，缓存文件file_1停止追加新数据，新建缓存文件file_2缓存新数据data1
<ul>
<li>一次写入缓存文件的数据,其判断是否可写入文件使用的大小是其数据大小扩展至页大小(4KB)的倍数.<br>
例如: 数据大小是512Byte,实际会扩展至4KB,即使file_1剩余空间大小是512Byte也会被认为不足以存放数据</li>
</ul>
</li>
<li>缓存容量已达上限，先从缓存文件中删除旧的数据，直到有足够空间存放新的数据，继续向缓存文件追加新数据</li>
</ol>
<h3 id="缓存文件删除时机">缓存文件删除时机</h3>
<ol>
<li>行云停止或宕机时缓存文件会被删除</li>
<li>总缓存文件数超过<code>local_data_cache_max_file_num</code>时,旧的缓存文件会被删除</li>
</ol>
<h4 id="可缓存不代表全缓存-以下情况数据不会被缓存">可缓存不代表全缓存, 以下情况数据不会被缓存</h4>
<ol>
<li>待缓存数据长度大于<code>local_data_cache_file_max_size</code>不会被缓存</li>
<li>受IO线程数影响,受到IO阻塞影响的数据,直接放弃写入缓存文件中,避免因阻塞导致查询耗时倍增
<ul>
<li>可通过多次查询将因IO阻塞而未被缓存的数据写入到缓存文件中,即逐渐缓存全部可缓存数据的过程,查询会因缓存增加而耗时减少。<strong>建议</strong></li>
<li><code>local_data_cache_write_thread_num</code> 修改为64,会使得所有IO都用于缓存,可使在第一次查询时缓存所有可缓存数据。<strong>不建议,会阻塞其他SQL执行</strong></li>
</ul>
</li>
</ol>
<h3 id="不同缓存策略下缓存节点选择规则">不同缓存策略下缓存节点选择规则</h3>
<div class="tabs" id="choose-node"><ul class="nav-tabs"><li class="tab"><a href="#choose-node-1">no cache</a></li><li class="tab active"><a href="#choose-node-2">auto cache</a></li><li class="tab"><a href="#choose-node-3">global cache</a></li></ul><div class="tab-content"><div class="tab-pane" id="choose-node-1"><p>无可缓存节点</p></div><div class="tab-pane active" id="choose-node-2"><ol>
<li>排除副本节点后,最多两个可缓存节点;</li>
<li>优先使用已缓存数据占比少的节点,该节点会持有10分钟优先权,10分钟后才会按已缓存数据占比重新选择</li>
<li>使用系统表<code>V$USER_TAB_CACHE_DISTR</code>查询同一个表的可缓存节点,也相当于一次表查询操作,会触发节点优先权计时,即查询前若使用<code>V$USER_TAB_CACHE_DISTR</code>查询表的可缓存节点,那么节点失去优先权倒计时已开始计时</li>
</ol></div><div class="tab-pane" id="choose-node-3"><ol>
<li>排除副本节点后的所有节点都为可缓存节点</li>
<li>无节点上下线,保持长期使用一节点读取某文件的可缓存节点</li>
</ol></div></div></div>
<h2 id="查询各节点缓存情况">查询各节点缓存情况</h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$LOCAL_DATA_CACHE_STATUS;</span><br></pre></td></tr></table></figure>
<h2 id="查询某表的可缓存节点">查询某表的可缓存节点</h2>
<div class="tabs" id="v$user_tab_cache_distr"><ul class="nav-tabs"><li class="tab active"><a href="#v$user_tab_cache_distr-1">systemadmin用户</a></li><li class="tab"><a href="#v$user_tab_cache_distr-2">system用户</a></li><li class="tab"><a href="#v$user_tab_cache_distr-3">普通用户</a></li></ul><div class="tab-content"><div class="tab-pane active" id="v$user_tab_cache_distr-1"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$USER_TAB_CACHE_DISTR <span class="keyword">WHERE</span> DATABASE_NAME <span class="operator">=</span> <span class="string">&#x27;database_name&#x27;</span> <span class="keyword">AND</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;schema_name&#x27;</span> <span class="keyword">AND</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="v$user_tab_cache_distr-2"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$USER_TAB_CACHE_DISTR <span class="keyword">WHERE</span> SCHEMA_NAME <span class="operator">=</span> <span class="string">&#x27;schema_name&#x27;</span> <span class="keyword">AND</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="v$user_tab_cache_distr-3"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$USER_TAB_CACHE_DISTR <span class="keyword">WHERE</span> TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;table_name&#x27;</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<h2 id="缓存文件">缓存文件</h2>
<h3 id="查看缓存文件文件">查看缓存文件文件</h3>
<h4 id="精准查找">精准查找</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +L1 | grep <span class="string">&quot;data-cache-<span class="variable">$&#123;hostname&#125;</span>-<span class="variable">$&#123;service_port&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +L1 | grep <span class="string">&quot;data-cache-cirrodata04-62622&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="模糊查找-适用多个节点一起看-不用更改-hostname">模糊查找,适用多个节点一起看,不用更改<code>$&#123;hostname&#125;</code></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +L1 | grep <span class="string">&quot;data-cache&quot;</span> | grep <span class="string">&quot;<span class="variable">$&#123;service_port&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsof +L1 | grep <span class="string">&quot;data-cache&quot;</span> | grep <span class="string">&quot;62622&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="循环查看缓存文件数">循环查看缓存文件数</h3>
<p>每3秒打印一次缓存文件数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> lsof +L1 | grep -c <span class="string">&quot;data-cache-<span class="variable">$&#123;hostname&#125;</span>-<span class="variable">$&#123;service_port&#125;</span>&quot;</span>; <span class="built_in">sleep</span> 3; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> lsof +L1 | grep -c <span class="string">&quot;data-cache-cirrodata04-62622&quot;</span>; <span class="built_in">sleep</span> 3; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="profile关键字">profile关键字</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Remote Read Data Cache Hit Bytes</td>
<td>从缓存中读取到的总字节数</td>
</tr>
<tr>
<td>Remote Read Data Cache Hit Cnt</td>
<td>命中缓存次数,即读缓存次数</td>
</tr>
<tr>
<td>Remote Read Data Cache Miss Bytes</td>
<td>多少字节是缓存中没有的</td>
</tr>
<tr>
<td>Remote Read Data Cache Miss Cnt</td>
<td>未命中缓存次数,即不是从缓存中读取的次数</td>
</tr>
<tr>
<td>Remote Read Data Cache Partial Hit Cnt</td>
<td>部分命中次数,有多少次读取有部分数据是从缓存中读的</td>
</tr>
<tr>
<td>Remote Read Data Cache Read Time</td>
<td>从缓存中读取总耗时</td>
</tr>
<tr>
<td>Remote Read Data Cache Write Time</td>
<td>写缓存数据总耗时</td>
</tr>
</tbody>
</table>
<h3 id="查看profile主要信息-日志过滤">查看profile主要信息,日志过滤</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -aE <span class="string">&quot;Sql Statement|Hdfs Remote Bytes Read|Hdfs Local Bytes Read|Remote Read Data Cache|Fragment-&quot;</span> <span class="variable">$&#123;profile_path&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -aE <span class="string">&quot;Sql Statement|Hdfs Remote Bytes Read|Hdfs Local Bytes Read|Remote Read Data Cache|Fragment-&quot;</span> <span class="built_in">log</span>/xcloudd.PROFILE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>想看到较完整SQL可以添加 -A选项 -A4 表示也展示过滤行后的4行</p>
</blockquote>
<p>示例2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -aEA4 <span class="string">&quot;Sql Statement|Hdfs Remote Bytes Read|Hdfs Local Bytes Read|Remote Read Data Cache|Fragment-&quot;</span> <span class="built_in">log</span>/PROFILE_.log20230423-110817.5028</span><br></pre></td></tr></table></figure>
<h3 id="如何判断是否使用数据缓存">如何判断是否使用数据缓存</h3>
<ol>
<li>执行节点是可缓存节点查看profile中<a href="#%E6%9F%A5%E7%9C%8Bprofile%E4%B8%BB%E8%A6%81%E4%BF%A1%E6%81%AF%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4">Fragment-</a>后的节点是否在系统表<a href="#%E6%9F%A5%E8%AF%A2%E5%90%84%E8%8A%82%E7%82%B9%E7%BC%93%E5%AD%98%E6%83%85%E5%86%B5">V$LOCAL_DATA_CACHE_STATUS</a>的<code>CACHE_NODES</code>列显示的节点中</li>
<li>profile中Remote Read Data Cache任意一项不为0即表示使用了数据缓存,而Remote Read Data Cache Miss Bytes 和 Remote Read Data Cache Write Time 不为0,则说明有写缓存（不代表最终会落盘,遵循<a href="#%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E8%A7%84%E5%88%99">数据缓存规则</a>）</li>
<li>local_data_cache_file_max_size配置足够大,否则即使有写缓存,但因数据过大实际不会缓存</li>
</ol>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>负责模块相关配置参数</title>
    <url>/2023/01/12/33/</url>
    <content><![CDATA[<h2 id="hdfs句柄缓存模块">hdfs句柄缓存模块</h2>
<div class="tabs" id="handle-cache"><ul class="nav-tabs"><li class="tab active"><a href="#handle-cache-1">3.0</a></li><li class="tab"><a href="#handle-cache-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="handle-cache-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_handle_cache_bucket_num</td>
<td>文件句柄缓存使用的分桶数量,用于减少并发时的冲突.</td>
<td>int32</td>
<td>64</td>
<td>[4, 256]</td>
</tr>
<tr>
<td>file_handle_cache_enable</td>
<td>文件句柄缓存开关,设置是否使用文件句柄缓存.</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>file_handle_cache_num</td>
<td>文件句柄缓存最大可缓存的文件句柄的数量.file_handle_cache_enable为true时有效.</td>
<td>int32</td>
<td>100000</td>
<td>[10000, 1000000]</td>
</tr>
<tr>
<td>file_handle_cache_swapout_timeout</td>
<td>文件句柄缓存中未被使用的句柄最长可保留的时间.</td>
<td>int64</td>
<td>21600</td>
<td>[1h, 1d]</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="handle-cache-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>num_file_handle_cache_partitions</td>
<td>文件句柄缓存使用的分区数量（用于将句柄缓存拆成多个分区）.</td>
<td>uint64</td>
<td>16</td>
<td>[1, uint64_max]</td>
</tr>
<tr>
<td>cache_file_handle</td>
<td>文件句柄缓存开关,设置是否使用文件句柄缓存.</td>
<td>bool</td>
<td>true</td>
<td>true/false</td>
</tr>
<tr>
<td>max_cached_file_handles</td>
<td>文文件句柄缓存最大可缓存的文件句柄的数量.</td>
<td>uint64</td>
<td>20000</td>
<td>[0, uint64_max]</td>
</tr>
<tr>
<td>unused_file_handle_timeout_sec</td>
<td>文件句柄缓存中未被使用的句柄最长可保留的时间(秒).</td>
<td>uint64</td>
<td>21600</td>
<td>[0, uint64_max]</td>
</tr>
</tbody>
</table></div></div></div>
<h2 id="LOB模块">LOB模块</h2>
<div class="tabs" id="lob"><ul class="nav-tabs"><li class="tab active"><a href="#lob-1">3.0</a></li><li class="tab"><a href="#lob-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="lob-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>compaction_lob_file_valid_threshold</td>
<td>每个lob数据文件中允许无效的lob个数占总lob个数的比例小于该比例.</td>
<td>double</td>
<td>0.5</td>
<td>(0, 1]</td>
</tr>
<tr>
<td>compaction_lob_tiny_file_num_threshold</td>
<td>compaction时,LOB微小文件必须进行compaction的数据阈值.微小文件的数量超过该值时,也必须进行compaction.</td>
<td>int32</td>
<td>50</td>
<td>[1, 100]</td>
</tr>
<tr>
<td>compaction_lob_tiny_file_size_threshold</td>
<td>lob compaction的时候,LOB文件大小小于该临界值的文件认为是小文件.</td>
<td>int64</td>
<td>1073741824</td>
<td>[128MB, 4GB]</td>
</tr>
<tr>
<td>lob_index_cache_num</td>
<td>LOB Writer中的索引Cache的数量.用于写入LOB数据.</td>
<td>int32</td>
<td>1024</td>
<td>[128, 4096]</td>
</tr>
<tr>
<td>lob_insert_cache_size</td>
<td>内部表加载时,用于拷贝LOB数据的缓存大小.</td>
<td>int32</td>
<td>1048576</td>
<td>[1MB, 2GB)</td>
</tr>
<tr>
<td>max_lob_size</td>
<td>LOB类型支持最大数据长度.</td>
<td>int64</td>
<td>4294967296</td>
<td>[16MB, 8GB]</td>
</tr>
<tr>
<td>lob_compression_type</td>
<td>LOB数据文件中的压缩类型.uncompressed: 表示不压缩;lz4: 表示lz4.</td>
<td>string</td>
<td>uncompressed</td>
<td>uncompresse,lz4</td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="lob-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>lob_delete_factor</td>
<td>每个lob数据文件中允许无效的lob个数占总lob个数的比例小于该比例.</td>
<td>double</td>
<td>0.5</td>
<td>(0, 1]</td>
</tr>
<tr>
<td>lob_compaction_small_files_cnt</td>
<td>LOB小文件的数量达到该临界值的时候，也需要进行compaction.</td>
<td>int32</td>
<td>50</td>
<td>[1, 100]</td>
</tr>
<tr>
<td>lob_compaction_small_file_size</td>
<td>lob compaction的时候,LOB文件大小小于该临界值的文件认为是小文件.</td>
<td>int64</td>
<td>1073741824</td>
<td><div style="white-space: nowrap">[128MB, 4GB]</div></td>
</tr>
<tr>
<td>lob_writer_cache_index_cnt</td>
<td>每一个lob Writer缓存的lob索引的数量.</td>
<td>int32</td>
<td>1024</td>
<td>[128, 4096]</td>
</tr>
<tr>
<td>lob_copy_data_length</td>
<td>local insert时候，拷贝数据需要的缓存长度.</td>
<td>int32</td>
<td>1048576</td>
<td>[1MB, 2GB)</td>
</tr>
<tr>
<td>lob_max_data_size</td>
<td>lob类型支持最大数据长度为4G.</td>
<td>int64</td>
<td>4294967296</td>
<td>[16MB, 8GB]</td>
</tr>
<tr>
<td>lob_compressionType</td>
<td>lob数据压缩方式，默认0：表示不压缩，1：表示lz4.</td>
<td>int32</td>
<td>0</td>
<td>{0, 1}</td>
</tr>
</tbody>
</table></div></div></div>
<h2 id="动态参数模块">动态参数模块</h2>
<div class="tabs" id="dynamic-parameter"><ul class="nav-tabs"><li class="tab active"><a href="#dynamic-parameter-1">3.0</a></li><li class="tab"><a href="#dynamic-parameter-2">3.0之前的版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dynamic-parameter-1"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>parameter_setting_sync_timeout</td>
<td>动态参数设定的同步超时时间.如果超时,则不再等待其他节点的同步状态,可能导致其他节点使用的参数不是最新值.</td>
<td>int32</td>
<td>5</td>
<td><div style="white-space: nowrap">[1, 100]</div></td>
</tr>
</tbody>
</table></div><div class="tab-pane" id="dynamic-parameter-2"><table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>param_update_timeout</td>
<td>参数修改指令单个节点超时时间，单位s.</td>
<td>int32</td>
<td>5</td>
<td>[1, 100]</td>
</tr>
</tbody>
</table></div></div></div>
<h3 id="数据缓存模块">数据缓存模块</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>consistent_hashing_min_virtual_node_count</td>
<td>数据缓存节点选择时一致性哈希的最小虚拟节点数.</td>
<td>int32</td>
<td>1000</td>
<td>(0,5000)</td>
</tr>
<tr>
<td>local_data_cache_dir</td>
<td>配置缓存数据的存储目录的绝对路径和每个目录的容量大小的字符串,不同路径使用英文逗号隔开,使用英文冒号分割路径和容量大小,例如: data/0,/data/1:1TB.代表缓存最大2TB,/data/0 和 /data/1分别最大1TB. 请注意,主机上每个CirroData进程必须有唯一的数据缓存目录.默认为空,代表禁用.</td>
<td>string</td>
<td>空</td>
<td>[4KB,4TB]</td>
</tr>
<tr>
<td>local_data_cache_enable</td>
<td>是否为远程读开启数据缓存.若需要启用数据缓存,则同时需要配置local_data_cache_dir参数.</td>
<td>bool</td>
<td>false</td>
<td>true/false</td>
</tr>
<tr>
<td>local_data_cache_file_max_size</td>
<td>缓存文件在停止追加数据前可以增加到的最大值,建议与配置的缓存存储目录空间大小保持一致.</td>
<td>string</td>
<td>1099511627776</td>
<td>[4KB,4TB]</td>
</tr>
<tr>
<td>local_data_cache_max_file_num</td>
<td>允许打开的最大文件数,不能小于指定数据缓存目录的数量.若有两个存储目录,则每个存储目录下最大可打开文件数为n/2.</td>
<td>int32</td>
<td>1000</td>
<td><div style="white-space: nowrap">[数据缓存存储目录个数,int32_max]</div></td>
</tr>
<tr>
<td>local_data_cache_write_thread_num</td>
<td>每个数据缓存目录允许插入数据的并发线程数.</td>
<td>int32</td>
<td>1</td>
<td>(0,int32_max]</td>
</tr>
<tr>
<td>local_data_cache_policy</td>
<td>本地数据缓存策略.NO_CACHE: 不进行本地缓存 AUTO_CACHE: 自动选择节点进行缓存（最多选择两个） GLOBAL_CACHE: 所有节点都可以缓存</td>
<td>string</td>
<td>auto_cache</td>
<td>no_cache,auto_cache,global_cache</td>
</tr>
</tbody>
</table>
<h3 id="对象存储">对象存储</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>s3_block_size</td>
<td>S3存储使用的虚拟块大小, CSV并发扫描时使用.</td>
<td>int32</td>
<td>268435456(256MB)</td>
<td>(0, 2<sup>31</sup>-1]</td>
</tr>
<tr>
<td>s3_multipart_chunk_size</td>
<td>S3分批上传的批次大小, S3上传较大数据文件支持分批上传, 小于单批次大小的文件直接上传.</td>
<td>int32</td>
<td>157286400(150MB)</td>
<td><div style="white-space: nowrap">[5242880, 2<sup>31</sup>-1]</div></td>
</tr>
</tbody>
</table>
<h3 id="hadoop-s3a-core-site-xml配置">hadoop s3a core-site.xml配置</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>参数类型</th>
<th>默认值</th>
<th>参数值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>hadoop.tmp.dir</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.access.key</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.secret.key</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.endpoint</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.block.size</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.multipart.size</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.impl</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.connection.ssl.enabled</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.buffer.dir</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.fast.upload</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.multipart.threshold</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fs.s3a.fast.upload.buffer</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>配置参数</tag>
      </tags>
  </entry>
  <entry>
    <title>问题定位</title>
    <url>/2023/05/02/32/</url>
    <content><![CDATA[<h2 id="设置bash命令行提示符的样式">设置bash命令行提示符的样式</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&quot;\[\e[1;32m\]\u\[\e[1;31m\]@\[\e[1;33m\]\h\[\e[1;35m\]:\[\e[0;36m\]\w\[\e[1;35m\]\\$ \[\e[0m&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="解压已压缩的日志">解压已压缩的日志</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> tar <span class="keyword">in</span> INFO*bz2 ; <span class="keyword">do</span> tar xvf <span class="variable">$tar</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="查看堆栈对应的代码行">查看堆栈对应的代码行</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addr2line -e bin/xcloudd <span class="variable">$&#123;堆栈地址&#125;</span></span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addr2line -e bin/xcloudd 0x37f75d1</span><br></pre></td></tr></table></figure>
<h2 id="SQL卡住定位">SQL卡住定位</h2>
<ol>
<li>获取sql的<code>Query Id</code></li>
<li>替换以下命令中<code>Query Id</code>(仅最后一个冒号前的内容),执行命令,结果为没有返回的子计划id</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -a <span class="string">&quot;352c18e1:644e7347:1bf&quot;</span> <span class="built_in">log</span>/INFO_* | awk <span class="string">&#x27;/InitFragment/ || /coord.*FragmentReport/ &#123;print $6&#125;&#x27;</span> | sed -r <span class="string">&#x27;s/.*@//g&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -u</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>过滤出子计划id的日志，找到<code>Open</code>处的线程号tid</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -a <span class="string">&quot;352c18e1:644e7347:1bf:1&quot;</span> <span class="built_in">log</span>/INFO_* | grep <span class="string">&quot;Open&quot;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>查看调用堆栈,多执行几次,看看堆栈是否有变动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pstack <span class="variable">$&#123;tid&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="查找日志中的堆栈">查找日志中的堆栈</h2>
<ol>
<li>搜索报错信息关键字</li>
<li>搜索关键字<code>Traced call stack for</code>,上下查找</li>
<li>若无堆栈,找到报错信息所在线程,查看该线程的日志,查找报错(注意有的日志不带error等错关键字需要自行甄别)</li>
</ol>
<h2 id="打印所有线程堆栈到thread-info-txt文件">打印所有线程堆栈到<code>thread_info.txt</code>文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb -q --batch --ex <span class="string">&quot;set height 0&quot;</span> --ex <span class="string">&quot;set logging file thread_info.txt&quot;</span> --ex <span class="string">&quot;set logging on&quot;</span> --ex <span class="string">&quot;thread apply all  bt&quot;</span> --ex <span class="string">&quot;set logging off&quot;</span> bin/xcloudd core.xxx</span><br></pre></td></tr></table></figure>
<h2 id="gdb调试core文件">gdb调试core文件</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用stl_view.gdb脚本打印参数，pvector plist 等</span></span><br><span class="line"><span class="built_in">source</span> [stl_view.gdb路径]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭命令行分页功能</span></span><br><span class="line"><span class="built_in">set</span> pagination off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有线程堆栈</span></span><br><span class="line">thread apply all bt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有线程</span></span><br><span class="line">info threads</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到该线程</span></span><br><span class="line">thread tid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印（char*）i的字符内容</span></span><br><span class="line">x  /10c &amp;i</span><br></pre></td></tr></table></figure>
<h2 id="动态参数">动态参数</h2>
<h3 id="查看总超时时间">查看总超时时间</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -a <span class="string">&quot;dynamic parameter total timeout is&quot;</span> <span class="built_in">log</span>/xcloudd.INFO</span><br></pre></td></tr></table></figure>
<h3 id="查看节点同步回报是否正常">查看节点同步回报是否正常</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -i <span class="string">&quot;SetFeedBackInfo&quot;</span> <span class="built_in">log</span>/xclodd.INFO</span><br></pre></td></tr></table></figure>
<h2 id="查看压缩方式">查看压缩方式</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -a <span class="string">&quot;CompressionCodec&quot;</span> <span class="built_in">log</span>/xcloudd.INFO</span><br></pre></td></tr></table></figure>
<h2 id="SQLDeveloper连接失败">SQLDeveloper连接失败</h2>
<h3 id="报错Login-failed-invalid-username-or-password">报错<code>Login failed, invalid username or password.</code></h3>
<ol>
<li>查看kv状态</li>
<li>kv若正常,检查ntp服务</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntptime</span><br></pre></td></tr></table></figure>
<h2 id="日志报错HDFSMetaQueryProxy">日志报错<code>HDFSMetaQueryProxy</code></h2>
<p>检查<code>kerberos_user_principal</code>与<code>kerberos_keytab_file</code>是否配置正确</p>
<h2 id="锁">锁</h2>
<p>检查是否有其他地方也会获取该锁，即争抢锁</p>
<h2 id="找堆栈">找堆栈</h2>
<ol>
<li>根据报错搜索日志</li>
<li>找到该日志中全大写的报错定义名</li>
<li>根据报错定义名搜索报错堆栈(可能有多个)</li>
</ol>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>集群搭建</title>
    <url>/2022/07/06/02/</url>
    <content><![CDATA[<div class="tabs" id="zookeeper"><ul class="nav-tabs"><li class="tab active"><a href="#zookeeper-1">3.0版</a></li><li class="tab"><a href="#zookeeper-2">3.0之前的旧版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="zookeeper-1"><h3 id="RegistrationCenter">RegistrationCenter</h3>
<p>配置文件 conf/configuration-cea.xml (好像是cea使用的配置文件)<br>
通过编译命令打包生成RegistrationCenter,需要手动在conf添加配置文件<code>zoo.cfg</code>,可复制conf目录下的<code>zoo_sample.cfg</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>
<h4 id="配置参数">配置参数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dataDir</td>
<td style="text-align:left">数据目录，用于存放zookeeper的数据</td>
</tr>
<tr>
<td style="text-align:left">clientPort</td>
<td style="text-align:left">监听客户端连接的端口</td>
</tr>
</tbody>
</table>
<h4 id="启动命令">启动命令</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure>
<h3 id="HDFS元数据代理">HDFS元数据代理</h3>
<h4 id="配置参数-2">配置参数</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">xcloud_helper_rpc_port</td>
<td style="text-align:left">xcloud与helper通信的RPC端口</td>
<td style="text-align:left">19091</td>
</tr>
<tr>
<td style="text-align:left">cea_detection_udp_port (新版中该参数已删除)</td>
<td style="text-align:left">与xcloud_helper_rpc_port保持一致即可</td>
<td style="text-align:left">19091</td>
</tr>
<tr>
<td style="text-align:left">cirrofs_user</td>
<td style="text-align:left">CirroFS集群管理员账号，与CirroEngine的cirrofs_user一致</td>
<td style="text-align:left">hdfs 或 hadoop 公共环境为cirrofs</td>
</tr>
<tr>
<td style="text-align:left">root_name</td>
<td style="text-align:left">与CirroeEngine的root_name保持一致</td>
<td style="text-align:left">xcloud</td>
</tr>
<tr>
<td style="text-align:left">cluster_name 旧版名称为engine_cluster_name</td>
<td style="text-align:left">与CirroeEngine的cluster_name保持一致</td>
<td style="text-align:left">xcloud_3.0</td>
</tr>
<tr>
<td style="text-align:left">registrationcenter_server</td>
<td style="text-align:left">zookeeper ip:port 与CirroeEngine的registrationcenter_server保持一致</td>
<td style="text-align:left">172.16.44.37:12345</td>
</tr>
</tbody>
</table>
<h4 id="公共环境下额外配置">公共环境下额外配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kerberos_user_principal</td>
<td style="text-align:left">Kerberos标识</td>
<td style="text-align:left">cirrofs/_HOST@BONC4.COM</td>
</tr>
<tr>
<td style="text-align:left">kerberos_keytab_file</td>
<td style="text-align:left">/home/cirrofs/cirrofs_cfs/key/cirrofs.keytab</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="非必要配置-若启动失败可配置排查原因">非必要配置,若启动失败可配置排查原因</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cirrodata_java_home</td>
<td style="text-align:left">用户指定的JAVA_HOME环境变量，与CirroEngine的JAVA_HOME一致,要求jdk版本不低于1.8</td>
<td style="text-align:left">/usr/local/jdk</td>
</tr>
<tr>
<td style="text-align:left">cirrodata_hadoop_home</td>
<td style="text-align:left">用户指定的HADOOP_HOME环境变量，与CirroEngine的HADOOP_HOME一致</td>
<td style="text-align:left">/opt/cloudera/parcels/CDH-5.14.0-1.cdh5.14.0.p0.24/lib/hadoop</td>
</tr>
</tbody>
</table>
<h4 id="启动命令-2">启动命令</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python daemon.py start</span><br></pre></td></tr></table></figure>
<h4 id="若启动失败，可开启日志，在logs目录中查看日志">若启动失败，可开启日志，在logs目录中查看日志</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python daemon.py start <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="CirroEngine行云计算引擎">CirroEngine行云计算引擎</h3>
<h4 id="公共配置">公共配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cluster_name</td>
<td style="text-align:left">集群名，需要与hdfs元数据配置的保持一致</td>
<td style="text-align:left">gyf_xcloud_2.15_number</td>
</tr>
<tr>
<td style="text-align:left">registrationcenter_server</td>
<td style="text-align:left">zookeeper安装的节点ip与端口号</td>
<td style="text-align:left">172.16.44.42:6361</td>
</tr>
<tr>
<td style="text-align:left">root_name</td>
<td style="text-align:left">CirroFS根目录</td>
<td style="text-align:left">xcloud_gyf</td>
</tr>
<tr>
<td style="text-align:left">client_arbiter_address_list</td>
<td style="text-align:left">ARBITER的地址信息</td>
<td style="text-align:left">xcloud37:5350,xcloud38:5350,xcloud39:5350</td>
</tr>
<tr>
<td style="text-align:left">cirrofs_user</td>
<td style="text-align:left">访问CirroFS的账号,在同时指定cirrofs_user和principal和keytab的情况下，cirrofs_user会被忽略</td>
<td style="text-align:left">hdfs 或 hadoop 公共环境为cirrofs</td>
</tr>
</tbody>
</table>
<h4 id="进程组配置">进程组配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">grm_inter_port</td>
<td style="text-align:left">grm rpc监听端口</td>
</tr>
<tr>
<td style="text-align:left">internal_port</td>
<td style="text-align:left">内部通信端口</td>
</tr>
<tr>
<td style="text-align:left">domain_port</td>
<td style="text-align:left">跨域通信的端口</td>
</tr>
<tr>
<td style="text-align:left">service_port</td>
<td style="text-align:left">对外服务端口.外部通过该端口访问数据库.</td>
</tr>
<tr>
<td style="text-align:left">metric_port</td>
<td style="text-align:left">指标采集服务export端口</td>
</tr>
<tr>
<td style="text-align:left">brpc_server_port</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="存储过程">存储过程</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">store_procedure_server_list</td>
<td style="text-align:left">存储过程引擎的服务地址，用于计算UDF以及UDF等的创建; ip:port</td>
</tr>
</tbody>
</table>
<h4 id="公共环境下额外配置-2">公共环境下额外配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kerb_principal</td>
<td style="text-align:left">Kerberos标识</td>
<td style="text-align:left">cirrofs/_HOST@BONC4.COM</td>
</tr>
<tr>
<td style="text-align:left">kerb_keytab_file</td>
<td style="text-align:left">Kerberos认证文件路径</td>
<td style="text-align:left">/home/cirrofs/cirrofs_cfs/key/cirrofs.keytab</td>
</tr>
</tbody>
</table>
<h4 id="非必要配置-若启动崩溃可配置排查原因">非必要配置,若启动崩溃可配置排查原因</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">cirrodata_java_home</td>
<td style="text-align:left">用户指定的java home路径,要求版本不低于1.8</td>
<td style="text-align:left">/usr/local/jdk</td>
</tr>
<tr>
<td style="text-align:left">cirrodata_hadoop_home</td>
<td style="text-align:left">用户指定的hadoop home路径</td>
<td style="text-align:left">/opt/cloudera/parcels/CDH-5.14.0-1.cdh5.14.0.p0.24/lib/hadoop</td>
</tr>
<tr>
<td style="text-align:left">brpc_dsink_enable</td>
<td style="text-align:left"></td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<h3 id="CirroKV">CirroKV</h3>
<p>使用<a href="kv%E7%BB%84%E4%BB%B6%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC.md">kv组件部署脚本</a>部署kv</p>
<h4 id="部署kv前先检查ntp服务是否正常-若不正常需更换节点，否则carrier会启动失败">部署kv前先检查ntp服务是否正常,若不正常需更换节点，否则carrier会启动失败</h4>
<p>执行以下命令查询ntp服务是否正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntptime</span><br></pre></td></tr></table></figure>
<p>结果显示有2个<code>OK</code>即npt正常,若有<code>ERROR</code>建议更换节点搭建kv<br>
或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpstat</span><br></pre></td></tr></table></figure>
<div class="note success"><h3 id="建议">建议</h3>
<p><strong>一个集群使用的zookeeper仅连接该集群对应的HDFS元数据代理</strong></p>
</div>
<h4 id="启动崩溃">启动崩溃</h4>
<ul>
<li>日志为kv init failed</li>
</ul>
<ol>
<li>检查client_arbiter_address_list是否配置错误</li>
<li>HDFS元数据代理与zookeeper是否启动</li>
<li>更新kv，重新启动kv引擎</li>
</ol>
<ul>
<li>日志为memory leak…</li>
</ul>
<ol>
<li>检查配置是cluster_name是否配置正确</li>
</ol></div><div class="tab-pane" id="zookeeper-2"><h3 id="zookeeper">zookeeper</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">dataDir</td>
<td style="text-align:left">zookeeper日志等文件存放位置</td>
<td style="text-align:left">/data1/dlc_group/gaoyuanfeng/2.15_number/zookeeper</td>
</tr>
<tr>
<td style="text-align:left">clientPort</td>
<td style="text-align:left">zookeeper连接端口号</td>
<td style="text-align:left">6361</td>
</tr>
</tbody>
</table>
<h3 id="HDFS元数据代理">HDFS元数据代理</h3>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">clusterName</td>
<td style="text-align:left">集群名</td>
<td style="text-align:left">gyf_xcloud_2.15_number</td>
</tr>
<tr>
<td style="text-align:left">zkUrl</td>
<td style="text-align:left">zookeeper连接地址ip + 端口号, 要zookeeper配置一致</td>
<td style="text-align:left">172.16.44.42:6361</td>
</tr>
<tr>
<td style="text-align:left">hdfsMetaQueryPort</td>
<td style="text-align:left">连接端口号</td>
<td style="text-align:left">16361</td>
</tr>
<tr>
<td style="text-align:left">xcloudName</td>
<td style="text-align:left">集群根目录</td>
<td style="text-align:left">xcloud_gyf</td>
</tr>
</tbody>
</table>
<h3 id="行云计算引擎">行云计算引擎</h3>
<h4 id="公共配置">公共配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">hdfs_meta_query_proxy_port</td>
<td style="text-align:left">hdfs元数据代理配置的端口号</td>
<td style="text-align:left">16361</td>
</tr>
<tr>
<td style="text-align:left">cluster_name</td>
<td style="text-align:left">集群名，需要与hdfs元数据配置的保持一致</td>
<td style="text-align:left">gyf_xcloud_2.15_number</td>
</tr>
<tr>
<td style="text-align:left">hdfs_meta_query_proxy_host</td>
<td style="text-align:left">hdfs元数据代理安装的节点ip</td>
<td style="text-align:left">172.16.44.42</td>
</tr>
<tr>
<td style="text-align:left">zk_server</td>
<td style="text-align:left">zookeeper安装的节点ip与端口号</td>
<td style="text-align:left">172.16.44.42:6361</td>
</tr>
<tr>
<td style="text-align:left">xcloud_root_name</td>
<td style="text-align:left">行云hdfs根目录</td>
<td style="text-align:left">xcloud_gyf</td>
</tr>
</tbody>
</table>
<h4 id="进程组配置">进程组配置</h4>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">webserve_port</td>
<td style="text-align:left">webserver对外提供服务的端口</td>
</tr>
<tr>
<td style="text-align:left">inter_port</td>
<td style="text-align:left">内部端口号</td>
</tr>
<tr>
<td style="text-align:left">domain_port</td>
<td style="text-align:left">domain port</td>
</tr>
<tr>
<td style="text-align:left">session_port</td>
<td style="text-align:left">外部端口号，SqlDeveloper连接的端口号</td>
</tr>
<tr>
<td style="text-align:left">udf_port</td>
<td style="text-align:left">自定义函数端口号</td>
</tr>
</tbody>
</table></div></div></div>
<h3 id="SqlDeveloper连接">SqlDeveloper连接</h3>
<p>端口即配置参数<code>service_port</code>(3.0)或<code>webserve_port</code>(旧版)</p>
<p>集群管理员连接用户名: <code>systemadmin</code>, 密码: <code>123456</code></p>
<p>数据库用户连接用户名: <code>system</code>, 密码: <code>123456</code></p>
<p>所有连接信息存储文件位置<br>
C:\Users\CirroData\xcloud\DBConfig.xml</p>
<h3 id="简要SQL">简要SQL</h3>
<h4 id="创建数据库">创建数据库</h4>
<p>systemadmin用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db_0;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> systemadmin identified <span class="keyword">by</span> <span class="string">&#x27;123456_&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="创建普通用户">创建普通用户</h4>
<p>system用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> user_0 IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456_&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> DATABASE LINK <span class="keyword">TO</span> user_0;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> user_0.<span class="operator">*</span> <span class="keyword">to</span> user_0;</span><br></pre></td></tr></table></figure>
<h4 id="高版本需要额外执行建表赋权">高版本需要额外执行建表赋权</h4>
<p>system用户执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>, <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="keyword">TO</span> user_0;</span><br></pre></td></tr></table></figure>
<h4 id="2-16-cgroup赋权">2.16 cgroup赋权</h4>
<p>sudo ./init-xcloud-cg.sh [user_name]:[user_name]</p>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>远程读数据缓存设计详解</title>
    <url>/2023/12/07/12/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>计算节点通过缓存远端数据，实现了对数据的快速访问和网络开销的减少。当需要读取相同的数据时，计算节点可以直接从缓存中获取，而无需通过网络进行数据传输。这种方式不仅提高了数据访问的速度，也大大减少了网络的负载。这种策略在处理大量数据时，尤其能体现出其优势，有效提升了整体的运行效率。</p>
<h2 id="缓存结构">缓存结构</h2>
<h3 id="元数据缓存-LRU缓存">元数据缓存(LRU缓存)</h3>
<p>缓存所有CacheKey与CacheEntry的键值对，使用LRU缓存，用于查找数据，淘汰旧数据以及控制数据缓存占用磁盘的大小作用；</p>
<ul>
<li>CacheKey：记录远程文件的文件名filename，文件最后一次被修改的时间戳mtime，目标数据所在的起始偏移量offset</li>
<li>CacheEntry：记录缓存数据所在的缓存文件的文件句柄，缓存数据所在的起始偏移量offset，缓存数据的长度length</li>
</ul>
<h3 id="数据缓存">数据缓存</h3>
<p>存储从远端读取到的数据到本地磁盘中，当数据被存储时，无论数据实际占用多少空间，都会以4KB的倍数进行分配和存储。即以页（page）为单位进行管理, 有助于提高系统性能和文件打孔。</p>
<p>缺点：如果数据大小不是4KB的整数倍，会将整个4KB的页分配给数据，导致浪费一些空间。</p>
<ul>
<li>存储目录：一个或多个，用于存储缓存文件，每个存储目录设置存储上限；多存储目录情况下在存储数据时，通过hash计算选择存储目录</li>
<li>缓存文件：存储具体的数据段，单文件最大可达到存储目录设置的存储上限，服务过程中保持open状态，属于临时文件，便于在服务停止或机器宕机后自动清理文件，避免产生垃圾文件</li>
</ul>
<h2 id="淘汰机制">淘汰机制</h2>
<ol>
<li>使用LRU策略淘汰旧数据，在删除CacheEntry的同时，通过文件打孔的方式，删除缓存文件中的旧数据</li>
<li>限制总缓存文件数，避免因不断淘汰而产生大量小文件</li>
</ol>
]]></content>
      <categories>
        <category>CirroData</category>
      </categories>
      <tags>
        <tag>数据缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>同步MySQL数据到Doris</title>
    <url>/2023/12/15/48/</url>
    <content><![CDATA[<h2 id="下载驱动程序">下载驱动程序</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://cdn.mysql.com//Downloads/Connector-J/mysql-connector-j-8.2.0.tar.gz .</span><br><span class="line">tar xvfz mysql-connector-j-8.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>也可以去MySQL官网下载其他版本<a href="https://dev.mysql.com/downloads/connector/j/">Connector/J</a><br>
建议选择<strong>Platform Independent</strong>的压缩包，解压即可使用</p>
<p><img src="/images/%E5%90%8C%E6%AD%A5MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Doris/Connector_J.png" alt=""></p>
<h2 id="be和fe配置jdbc驱动目录">be和fe配置jdbc驱动目录</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc_drivers_dir = /root/doris/mysql-connector-j-8.2.0</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E5%90%8C%E6%AD%A5MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Doris/%E9%85%8D%E7%BD%AEjdbc%E9%A9%B1%E5%8A%A8%E7%9B%AE%E5%BD%95.png" alt=""></p>
<h2 id="从MySQL导入数据到Doris示例">从MySQL导入数据到Doris示例</h2>
<ol>
<li>创建目标表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> example_tbl (</span><br><span class="line">    id <span class="type">INT</span> COMMENT &quot;id&quot;,</span><br><span class="line">		name <span class="type">VARCHAR</span>(<span class="number">20</span>)  COMMENT &quot;name&quot;</span><br><span class="line">)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(id) BUCKETS <span class="number">10</span></span><br><span class="line">PROPERTIES(&quot;replication_num&quot; <span class="operator">=</span> &quot;1&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建 MySQL CATALOG</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CREATE CATALOG jdbc_mysql PROPERTIES (</span></span><br><span class="line"><span class="comment">--     &quot;type&quot;=&quot;jdbc&quot;,</span></span><br><span class="line"><span class="comment">--     &quot;user&quot;=&quot;root&quot;,</span></span><br><span class="line"><span class="comment">--     &quot;password&quot;=&quot;123456&quot;,</span></span><br><span class="line"><span class="comment">--     &quot;jdbc_url&quot; = &quot;jdbc:mysql://172.16.48.9:4486/demo&quot;,</span></span><br><span class="line"><span class="comment">--     &quot;driver_url&quot; = &quot;mysql-connector-j-8.2.0.jar&quot;,</span></span><br><span class="line"><span class="comment">--     &quot;driver_class&quot; = &quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line"><span class="comment">-- )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> CATALOG jdbc_mysql PROPERTIES (</span><br><span class="line">    &quot;type&quot;<span class="operator">=</span>&quot;jdbc&quot;,</span><br><span class="line">    &quot;user&quot;<span class="operator">=</span>&quot;root&quot;,</span><br><span class="line">    &quot;jdbc_url&quot; <span class="operator">=</span> &quot;jdbc:mysql://172.16.48.9:4486&quot;,  <span class="comment">-- 可以不指定具体数据库</span></span><br><span class="line">    &quot;driver_url&quot; <span class="operator">=</span> &quot;mysql-connector-j-8.2.0.jar&quot;,</span><br><span class="line">    &quot;driver_class&quot; <span class="operator">=</span> &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E5%90%8C%E6%AD%A5MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Doris/CREATE_CATALOG.png" alt=""></p>
<ol start="3">
<li>查看 CATALOGS</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> CATALOGS;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E5%90%8C%E6%AD%A5MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Doris/SHOW_CATALOGS.png" alt=""></p>
<ol start="4">
<li>插入数据</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- INSERT INTO &lt;doris_Catalog_Name&gt;.&lt;db_name&gt;.&lt;table_name&gt; SELECT * FROM &lt;mysql_Catalog_Name&gt;.&lt;db_name&gt;.&lt;table_name&gt;;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> internal.demo.example_tbl <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> jdbc_mysql.demo.t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于当前在 doris CATALOG 下,可以省略Catalog_Name与db_name</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> example_tbl <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> jdbc_mysql.demo.t1;</span><br></pre></td></tr></table></figure>
<p><img src="/images/%E5%90%8C%E6%AD%A5MySQL%E6%95%B0%E6%8D%AE%E5%88%B0Doris/insert.png" alt=""></p>
<ol start="5">
<li>可以切换使用 MySQL 环境</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">switch jdbc_mysql;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前在MySQL CATALOG 下, 可以省略Catalog_Name与db_name</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> internal.demo.example_tbl <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>doris</category>
      </categories>
      <tags>
        <tag>CATALOG</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
