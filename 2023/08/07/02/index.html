<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yiyutingfeng.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Doris的数据模型">
<meta property="og:type" content="article">
<meta property="og:title" content="Doris的数据模型">
<meta property="og:url" content="https://yiyutingfeng.github.io/2023/08/07/02/index.html">
<meta property="og:site_name" content="BONC">
<meta property="og:description" content="Doris的数据模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yiyutingfeng.github.io/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/insert_and_compaction_agg.png">
<meta property="og:image" content="https://yiyutingfeng.github.io/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/select_agg.png">
<meta property="og:image" content="https://yiyutingfeng.github.io/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/merge_on_write_unique.png">
<meta property="article:published_time" content="2023-08-07T09:59:02.000Z">
<meta property="article:modified_time" content="2023-10-14T04:29:55.562Z">
<meta property="article:author" content="yiyutingfeng">
<meta property="article:tag" content="Doris">
<meta property="article:tag" content="Aggregate模型">
<meta property="article:tag" content="Unique模型">
<meta property="article:tag" content="Duplicate模型">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yiyutingfeng.github.io/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/insert_and_compaction_agg.png">


<link rel="canonical" href="https://yiyutingfeng.github.io/2023/08/07/02/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://yiyutingfeng.github.io/2023/08/07/02/","path":"2023/08/07/02/","title":"Doris的数据模型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Doris的数据模型 | BONC</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">BONC</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">Doris数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AGGREGATE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">AGGREGATE模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%94%9F%E8%81%9A%E5%90%88%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.2.</span> <span class="nav-text">发生聚合的阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">导入阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compaction%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Compaction阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">查询阶段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="nav-number">1.1.3.</span> <span class="nav-text">时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.4.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.5.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNIQUE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">UNIQUE模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E6%97%B6%E5%90%88%E5%B9%B6%EF%BC%88%E4%B8%8E%E8%81%9A%E5%90%88%E6%A8%A1%E5%9E%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="nav-number">1.2.1.</span> <span class="nav-text">读时合并（与聚合模型相同的实现方式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%90%88%E5%B9%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">写时合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unique%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%86%99%E6%97%B6%E5%90%88%E5%B9%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">Unique模型的写时合并实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%90%88%E5%B9%B6%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="nav-number">1.2.4.</span> <span class="nav-text">写时合并时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="nav-number">1.2.5.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DUPLICATE%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.</span> <span class="nav-text">DUPLICATE模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%BE-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">时序图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="nav-number">1.3.3.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="yiyutingfeng"
      src="/images/Chinchilla.jpg">
  <p class="site-author-name" itemprop="name">yiyutingfeng</p>
  <div class="site-description" itemprop="description">BONC工作总结</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="mailto:gaoyuanfeng@bonc.com.cn" title="电子邮箱 → mailto:gaoyuanfeng@bonc.com.cn" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>电子邮箱</a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/weixin.png" title="企业微信 → &#x2F;images&#x2F;weixin.png" rel="noopener me"><i class="fab fa-weixin fa-fw"></i>企业微信</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yiyutingfeng.github.io/2023/08/07/02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Chinchilla.jpg">
      <meta itemprop="name" content="yiyutingfeng">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BONC">
      <meta itemprop="description" content="BONC工作总结">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Doris的数据模型 | BONC">
      <meta itemprop="description" content="Doris的数据模型">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Doris的数据模型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-08-07 17:59:02" itemprop="dateCreated datePublished" datetime="2023-08-07T17:59:02+08:00">2023-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-14 12:29:55" itemprop="dateModified" datetime="2023-10-14T12:29:55+08:00">2023-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Doris/" itemprop="url" rel="index"><span itemprop="name">Doris</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Valine：</span>
  
    <a title="valine" href="/2023/08/07/02/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/08/07/02/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">Doris的数据模型</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1>Doris数据模型</h1>
<p>Doris 数据模型上目前分为三类:</p>
<ul>
<li>AGGREGATE（聚合模型）</li>
<li>UNIQUE（唯一主键模型）</li>
<li>DUPLICATE（明细模型）</li>
</ul>
<div class="note info"><p><strong>说明</strong></p>
<ol>
<li>在 Aggregate、Unique 和 Duplicate 三种数据模型中。底层的数据存储，是按照各自建表语句中，AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 中指定的列（<strong>不支持任意列，必须为前n列</strong>）进行排序存储的</li>
<li>三种模型都涉及前缀索引，即在排序的基础上，实现的一种根据给定前缀列，快速查询数据的索引方式，属于Doris内建的智能索引之一。</li>
<li>在查询过滤时使用AGGREGATE KEY、UNIQUE KEY 和 DUPLICATE KEY 中的指定列时，可以提高查询效率。</li>
<li>数据模型在建表时就已经确定，且无法修改</li>
</ol>
</div>
<p><strong>适用场景</strong>：</p>
<ul>
<li>AGGREGATE 模型适合有固定模式的报表类查询场景和多维分析业务</li>
<li>UNIQUE 模型适用于有主键唯一性约束需求的某些多维分析业务</li>
<li>DUPLICATE 模型适用于既没有主键，也没有聚合需求的场景</li>
</ul>
<h2 id="AGGREGATE模型">AGGREGATE模型</h2>
<h3 id="数据聚合">数据聚合</h3>
<p>假设有如下数据表模式：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>LARGEINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td></td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td></td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td></td>
<td>用户性别</td>
</tr>
<tr>
<td>last_visit_date</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>用户最后一次访问时间</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
<tr>
<td>max_dwell_time</td>
<td>INT</td>
<td>MAX</td>
<td>用户最大停留时间</td>
</tr>
<tr>
<td>min_dwell_time</td>
<td>INT</td>
<td>MIN</td>
<td>用户最小停留时间</td>
</tr>
</tbody>
</table>
<p>该模型将表中的列按照是否设置了 <code>AggregationType</code>，分为 Key (维度列) 和 Value（指标列）。没有设置 <code>AggregationType</code> 的，如 <code>user_id</code>、<code>date</code>、<code>age</code> … 等称为 <strong>Key</strong>，而设置了 <code>AggregationType</code> 的称为 <strong>Value</strong>。</p>
<p>如果转换成建表语句则如下（省略建表语句中的 Partition 和 Distribution 信息）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `<span class="type">date</span>` <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;数据灌入日期时间&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `last_visit_date` DATETIME REPLACE <span class="keyword">DEFAULT</span> &quot;1970-01-01 00:00:00&quot; COMMENT &quot;用户最后一次访问时间&quot;,</span><br><span class="line">    `cost` <span class="type">BIGINT</span> SUM <span class="keyword">DEFAULT</span> &quot;0&quot; COMMENT &quot;用户总消费&quot;,</span><br><span class="line">    `max_dwell_time` <span class="type">INT</span> MAX <span class="keyword">DEFAULT</span> &quot;0&quot; COMMENT &quot;用户最大停留时间&quot;,</span><br><span class="line">    `min_dwell_time` <span class="type">INT</span> MIN <span class="keyword">DEFAULT</span> &quot;99999&quot; COMMENT &quot;用户最小停留时间&quot;</span><br><span class="line">)</span><br><span class="line">AGGREGATE KEY(`user_id`, `<span class="type">date</span>`, `city`, `age`, `sex`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div class="note warning"><p><strong>注意</strong></p>
<ol>
<li><code>AGGREGATE KEY</code> 必须为前连续N列</li>
<li>除<code>AGGREGATE KEY</code>指定的列，所有列都必须指定聚合方式</li>
</ol>
</div>
<p>AGGREGATE KEY相同时，新旧记录进行聚合，目前有以下聚合方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">聚合方式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SUM</td>
<td>求和。适用数值类型。</td>
</tr>
<tr>
<td style="text-align:center">MIN</td>
<td>求最小值。适合数值类型。</td>
</tr>
<tr>
<td style="text-align:center">MAX</td>
<td>求最大值。适合数值类型。</td>
</tr>
<tr>
<td style="text-align:center">REPLACE</td>
<td>替换。对于维度列相同的行，指标列会按照导入的先后顺序，后导入的替换先导入的。</td>
</tr>
<tr>
<td style="text-align:center">REPLACE_IF_NOT_NULL</td>
<td>非空值替换。和 REPLACE 的区别在于对于null值，不做替换。字段默认值要给NULL，而不能是空字符串，否则会被替换成新字符串。</td>
</tr>
<tr>
<td style="text-align:center">HLL_UNION</td>
<td>HLL<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>类型的列的聚合方式，通过 HyperLogLog 算法聚合。</td>
</tr>
<tr>
<td style="text-align:center">BITMAP_UNION</td>
<td>BIMTAP<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>类型的列的聚合方式，进行位图的并集聚合。</td>
</tr>
</tbody>
</table>
<p>假设有以下导入数据（原始数据）：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 06:00:00</td>
<td>20</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00:00</td>
<td>15</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>北京</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>上海</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>广州</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>那么当这批数据正确导入到 Doris 中后，Doris 中最终存储如下：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>city</th>
<th>age</th>
<th>sex</th>
<th>last_visit_date</th>
<th>cost</th>
<th>max_dwell_time</th>
<th>min_dwell_time</th>
</tr>
</thead>
<tbody>
<tr>
<td>10000</td>
<td>2017-10-01</td>
<td>北京</td>
<td>20</td>
<td>0</td>
<td>2017-10-01 07:00:00</td>
<td>35</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>10001</td>
<td>2017-10-01</td>
<td>北京</td>
<td>30</td>
<td>1</td>
<td>2017-10-01 17:05:45</td>
<td>2</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>10002</td>
<td>2017-10-02</td>
<td>上海</td>
<td>20</td>
<td>1</td>
<td>2017-10-02 12:59:12</td>
<td>200</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-10-02</td>
<td>广州</td>
<td>32</td>
<td>0</td>
<td>2017-10-02 11:20:00</td>
<td>30</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-01</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-01 10:00:15</td>
<td>100</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10004</td>
<td>2017-10-03</td>
<td>深圳</td>
<td>35</td>
<td>0</td>
<td>2017-10-03 10:20:22</td>
<td>11</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="发生聚合的阶段">发生聚合的阶段</h3>
<h4 id="导入阶段">导入阶段</h4>
<p>原始数据在导入过程中，会根据表结构中的Key进行分组，相同Key的Value会根据表中定义的AggregationType进行聚合</p>
<p>由于Doris采用的是MVCC（Multi-version Cocurrent Control，多版本并发控制）机制进行的并发控制，所以每一次新的导入都是一个新的版本</p>
<h4 id="Compaction阶段">Compaction阶段</h4>
<p>在不断导入新数据后，虽然每个批次的数据都在导入阶段完成了聚合，但不同版本之间的数据仍存在相同key但value没有聚合的情况，这时候就需要Compaction对不同版本的数据进行合并，对数据进行二次聚合</p>
<h4 id="查询阶段">查询阶段</h4>
<p>由于Compaction是异步的，在用户查询的数据仍存在多个版本时，为保证查询结果一致，会获取所有版本的数据，再做一次聚合，将聚合后的结果展示给用户。</p>
<p>经过聚合，Doris 中最终只会存储聚合后的数据。换句话说，即明细数据会丢失，用户不能够再查询到聚合前的明细数据了。经过聚合，Doris 中最终只会存储聚合后的数据。换句话说，即明细数据会丢失，用户不能够再查询到聚合前的明细数据了。</p>
<h3 id="时序图">时序图</h3>
<ol>
<li>
<p>insert与compact阶段以某一批次加载中<code>insert</code>阶段与<code>compaction</code>阶段的聚合操作,以聚合方法为<code>SUM</code>为例,时序图如下：<br>
<img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/insert_and_compaction_agg.png" alt=""></p>
</li>
<li>
<p>查询阶段<br>
<img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/select_agg.png" alt=""></p>
</li>
</ol>
<p>聚合方法在工厂类<code>AggregateFunctionSimpleFactory</code>中注册，使用时通过<code>AggregateFunctionSimpleFactory</code>获取对应聚合方法类的指针<code>AggregateFunctionPtr</code>执行聚合操作</p>
<h3 id="适用场景">适用场景</h3>
<p>AGGREGATE模型可以提前聚合数据, 极大地降低聚合查询时所需扫描的数据量和查询的计算量，非常适合有固定模式的报表类查询场景和多维分析业务。</p>
<h3 id="缺点">缺点</h3>
<p>该模型对 count(*) 查询很不友好。同时因为固定了 Value 列上的聚合方式，在进行其他类型的聚合查询时，需要考虑语意正确性。</p>
<p>假设表结构如下：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>LARGEINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
</tbody>
</table>
<p>假设存储引擎中有如下两个已经导入完成的批次的数据：</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>可以看到，用户 10001 分属在两个导入批次中的数据还没有聚合。但是为了保证用户只能查询到如下最终聚合后的数据, 会在查询引擎中加入了聚合算子，来保证数据对外的一致性：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>另外，在聚合列（Value）上，执行与聚合类型不一致的聚合类查询时，要注意语意。比如我们在如上示例中执行如下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(cost) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>得到的结果是 5，而不是 1。</p>
<p>同时，这种一致性保证，在某些查询中，会极大的降低查询效率。</p>
<p>我们以最基本的 count(*) 查询为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<p>在其他数据库中，这类查询都会很快的返回结果。因为在实现上，我们可以通过如“导入时对行进行计数，保存 count 的统计信息”，或者在查询时“仅扫描某一列数据，获得 count 值”的方式，只需很小的开销，即可获得查询结果。但是在 Doris 的聚合模型中，这种查询的开销<strong>非常大</strong>。</p>
<p>以刚才的数据为例：</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>因为最终的聚合结果为：</p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>51</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
</tr>
</tbody>
</table>
<p>所以，<code>select count(*) from table;</code> 的正确结果应该为 <strong>4</strong>。但如果我们只扫描 <code>user_id</code> 这一列，如果加上查询时聚合，最终得到的结果是 <strong>3</strong>（10001, 10002, 10003）。而如果不加查询时聚合，则得到的结果是 <strong>5</strong>（两批次一共5行数据）。可见这两个结果都是不对的。</p>
<p>为了得到正确的结果，我们必须同时读取 <code>user_id</code> 和 <code>date</code> 这两列的数据，<strong>再加上查询时聚合</strong>，才能返回 <strong>4</strong> 这个正确的结果。也就是说，在 count(*) 查询中，Doris 必须扫描所有的 AGGREGATE KEY 列（这里就是 <code>user_id</code> 和 <code>date</code>），并且聚合后，才能得到语意正确的结果。当聚合列非常多时，count(*) 查询需要扫描大量的数据。</p>
<p>因此，当业务上有频繁的 count(*) 查询时，我们建议用户通过增加一个<strong>值恒为 1 的，聚合类型为 SUM 的列来模拟 count(*)</strong>。如刚才的例子中的表结构，我们修改如下：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregateType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>date</td>
<td>DATE</td>
<td></td>
<td>数据灌入日期</td>
</tr>
<tr>
<td>cost</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用户总消费</td>
</tr>
<tr>
<td>count</td>
<td>BIGINT</td>
<td>SUM</td>
<td>用于计算count</td>
</tr>
</tbody>
</table>
<p>增加一个 count 列，并且导入数据中，该列值<strong>恒为 1</strong>。则 <code>select count(*) from table;</code> 的结果等价于 <code>select sum(count) from table;</code>。而后者的查询效率将远高于前者。不过这种方式也有使用限制，就是用户需要自行保证，不会重复导入 AGGREGATE KEY 列都相同的行。否则，<code>select sum(count) from table;</code> 只能表述原始导入的行数，而不是 <code>select count(*) from table;</code> 的语义。</p>
<p>另一种方式，就是 <strong>将如上的 <code>count</code> 列的聚合类型改为 REPLACE，且依然值恒为 1</strong>。那么 <code>select sum(count) from table;</code> 和 <code>select count(*) from table;</code> 的结果将是一致的。并且这种方式，没有导入重复行的限制。</p>
<h2 id="UNIQUE模型">UNIQUE模型</h2>
<p>在1.2版本之前，该模型本质上是聚合模型的一个特例，也是一种简化的表结构表示方式。实现上和 AGGREGATE 模型 的 REPLACE 聚合方法一样，二者本质上相同，由于实现方式是读时合并（merge on read)，因此在一些聚合查询上性能不佳，自1.2版本 UNIQUE 模型引入新的实现方式，写时合并（merge on write），通过在写入时做一些额外的工作，实现了最优的查询性能，该实现有更好的聚合查询性能。默认情况下写时合并是关闭的。</p>
<h3 id="读时合并（与聚合模型相同的实现方式）">读时合并（与聚合模型相同的实现方式）</h3>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>IsKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td>Yes</td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td>Yes</td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>No</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>No</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>No</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>No</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>No</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>No</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>这是一个典型的用户基础信息表。这类数据没有聚合需求，只需保证主键唯一性。（这里的主键为 user_id + username）。那么我们的建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>而这个表结构，完全同等于以下使用聚合模型描述的表结构：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td></td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>REPLACE</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>REPLACE</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>REPLACE</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>REPLACE</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>REPLACE</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>REPLACE</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>及建表语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) REPLACE COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> REPLACE COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT REPLACE COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT REPLACE COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) REPLACE COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME REPLACE COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line">AGGREGATE KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="写时合并">写时合并</h3>
<p>Unqiue 模型的写时合并实现，与聚合模型是完全不同的两种模型了，查询性能更接近于 Duplicate 模型，在有主键约束需求的场景上相比聚合模型有较大的查询性能优势，尤其是在聚合查询以及需要用索引过滤大量数据的查询中。</p>
<p>写时合并默认关闭，用户可以通过添加下面的property来开启</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;enable_unique_key_merge_on_write&quot; <span class="operator">=</span> &quot;true&quot;</span><br></pre></td></tr></table></figure>
<p>仍然以上面的表为例，建表语句为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `user_id` LARGEINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户id&quot;,</span><br><span class="line">    `username` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;用户昵称&quot;,</span><br><span class="line">    `city` <span class="type">VARCHAR</span>(<span class="number">20</span>) COMMENT &quot;用户所在城市&quot;,</span><br><span class="line">    `age` <span class="type">SMALLINT</span> COMMENT &quot;用户年龄&quot;,</span><br><span class="line">    `sex` TINYINT COMMENT &quot;用户性别&quot;,</span><br><span class="line">    `phone` LARGEINT COMMENT &quot;用户电话&quot;,</span><br><span class="line">    `address` <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT &quot;用户地址&quot;,</span><br><span class="line">    `register_time` DATETIME COMMENT &quot;用户注册时间&quot;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNIQUE</span> KEY(`user_id`, `username`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`user_id`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;,</span><br><span class="line">&quot;enable_unique_key_merge_on_write&quot; <span class="operator">=</span> &quot;true&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>使用这种建表语句建出来的表结构，与聚合模型就完全不同了：</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>AggregationType</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>user_id</td>
<td>BIGINT</td>
<td></td>
<td>用户id</td>
</tr>
<tr>
<td>username</td>
<td>VARCHAR(50)</td>
<td></td>
<td>用户昵称</td>
</tr>
<tr>
<td>city</td>
<td>VARCHAR(20)</td>
<td>NONE</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>age</td>
<td>SMALLINT</td>
<td>NONE</td>
<td>用户年龄</td>
</tr>
<tr>
<td>sex</td>
<td>TINYINT</td>
<td>NONE</td>
<td>用户性别</td>
</tr>
<tr>
<td>phone</td>
<td>LARGEINT</td>
<td>NONE</td>
<td>用户电话</td>
</tr>
<tr>
<td>address</td>
<td>VARCHAR(500)</td>
<td>NONE</td>
<td>用户住址</td>
</tr>
<tr>
<td>register_time</td>
<td>DATETIME</td>
<td>NONE</td>
<td>用户注册时间</td>
</tr>
</tbody>
</table>
<p>在开启了写时合并选项的Unique表上，数据在导入阶段就会去将被覆盖和被更新的数据进行标记删除，同时将新的数据写入新的文件。在查询的时候，所有被标记删除的数据都会在文件级别被过滤掉，读取出来的数据就都是最新的数据，消除掉了读时合并中的数据聚合过程，并且能够在很多情况下支持多种谓词的下推。因此在许多场景都能带来比较大的性能提升，尤其是在有聚合查询的情况下。</p>
<div class="note warning"><ol>
<li>新的<code>Merge-on-write</code>实现默认关闭，且只能在建表时通过指定<code>property</code>的方式打开。</li>
<li>旧的<code>Merge-on-read</code>的实现无法无缝升级到新版本的实现（数据组织方式完全不同），如果需要改为使用写时合并的实现版本，需要手动执行<code>insert into unique-mow-table select * from source table</code>.</li>
<li>在Unique模型上独有的<code>delete sign</code>和<code>sequence col</code>，在写时合并的新版实现中仍可以正常使用，用法没有变化。</li>
</ol>
</div>
<h3 id="Unique模型的写时合并实现">Unique模型的写时合并实现</h3>
<p>Unique模型的写时合并实现没有聚合模型的局限性，还是以刚才的数据为例，写时合并为每次导入的rowset增加了对应的delete bitmap，来标记哪些数据被覆盖。第一批数据导入后状态如下</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
<td>false</td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>当第二批数据导入完成后，第一批数据中重复的行就会被标记为已删除，此时两批数据状态如下</p>
<p><strong>batch 1</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>50</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>10002</td>
<td>2017-11-21</td>
<td>39</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>batch 2</strong></p>
<table>
<thead>
<tr>
<th>user_id</th>
<th>date</th>
<th>cost</th>
<th>delete bit</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>2017-11-20</td>
<td>1</td>
<td>false</td>
</tr>
<tr>
<td>10001</td>
<td>2017-11-21</td>
<td>5</td>
<td>false</td>
</tr>
<tr>
<td>10003</td>
<td>2017-11-22</td>
<td>22</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>在查询时，所有在delete bitmap中被标记删除的数据都不会读出来，因此也无需进行做任何数据聚合，上述数据中有效的行数为4行，查询出的结果也应该是4行，也就可以采取开销最小的方式来获取结果，即前面提到的“仅扫描某一列数据，获得 count 值”的方式。</p>
<p>据官方文档介绍，在测试环境中，count(*) 查询在 Unique 模型的写时合并实现上的性能，相比聚合模型有10倍以上的提升。</p>
<h3 id="写时合并时序图">写时合并时序图</h3>
<p><img src="/images/Doris%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/merge_on_write_unique.png" alt=""></p>
<h3 id="缺点-2">缺点</h3>
<ol>
<li>无法利用 ROLLUP 等预聚合带来的查询优势。对于聚合查询有较高性能需求的用户，推荐使用自1.2版本加入的写时合并实现。</li>
<li>Unique 模型仅支持整行更新，如果用户既需要唯一主键约束，又需要更新部分列（例如将多张源表导入到一张 doris 表的情形），则可以考虑使用 Aggregate 模型，同时将非主键列的聚合类型设置为 REPLACE_IF_NOT_NULL。</li>
</ol>
<h2 id="DUPLICATE模型">DUPLICATE模型</h2>
<p>Duplicate 数据模型用于满足在某些多维分析场景下，数据既没有主键，也没有聚合需求的场景。</p>
<p>这种数据模型区别于 Aggregate 和 Unique 模型。数据完全按照导入文件中的数据进行存储，不会有任何聚合。即使两行数据完全相同，也都会保留。 而在建表语句中指定的 DUPLICATE KEY，只是用来指明底层数据按照那些列进行排序。</p>
<table>
<thead>
<tr>
<th>ColumnName</th>
<th>Type</th>
<th>SortKey</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>timestamp</td>
<td>DATETIME</td>
<td>Yes</td>
<td>日志时间</td>
</tr>
<tr>
<td>type</td>
<td>INT</td>
<td>Yes</td>
<td>日志类型</td>
</tr>
<tr>
<td>error_code</td>
<td>INT</td>
<td>Yes</td>
<td>错误码</td>
</tr>
<tr>
<td>error_msg</td>
<td>VARCHAR(1024)</td>
<td>No</td>
<td>错误详细信息</td>
</tr>
<tr>
<td>op_id</td>
<td>BIGINT</td>
<td>No</td>
<td>负责人id</td>
</tr>
<tr>
<td>op_time</td>
<td>DATETIME</td>
<td>No</td>
<td>处理时间</td>
</tr>
</tbody>
</table>
<p>建表语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> example_db.example_tbl</span><br><span class="line">(</span><br><span class="line">    `<span class="type">timestamp</span>` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;日志时间&quot;,</span><br><span class="line">    `type` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT &quot;日志类型&quot;,</span><br><span class="line">    `error_code` <span class="type">INT</span> COMMENT &quot;错误码&quot;,</span><br><span class="line">    `error_msg` <span class="type">VARCHAR</span>(<span class="number">1024</span>) COMMENT &quot;错误详细信息&quot;,</span><br><span class="line">    `op_id` <span class="type">BIGINT</span> COMMENT &quot;负责人id&quot;,</span><br><span class="line">    `op_time` DATETIME COMMENT &quot;处理时间&quot;</span><br><span class="line">)</span><br><span class="line">DUPLICATE KEY(`<span class="type">timestamp</span>`, `type`, `error_code`)</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`type`) BUCKETS <span class="number">1</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">&quot;replication_allocation&quot; <span class="operator">=</span> &quot;tag.location.default: 1&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种数据模型区别于 Aggregate 和 Unique 模型。数据完全按照导入文件中的数据进行存储，不会有任何聚合。即使两行数据完全相同，也都会保留。 而在建表语句中指定的 DUPLICATE KEY，只是用来指明底层数据按照那些列进行排序。</p>
<h3 id="时序图-2">时序图</h3>
<p>与<a href="#%E6%97%B6%E5%BA%8F%E5%9B%BE">Aggregate模型一样，仅没有聚合操作</a></p>
<h3 id="适用场景-2">适用场景</h3>
<p>适用于既没有聚合需求，又没有主键唯一性约束的原始数据的存储</p>
<h3 id="缺点-3">缺点</h3>
<p>无法利用预聚合的特性</p>
<h2 id="参考资料">参考资料</h2>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/doris/tree/branch-2.0">Doris 2.0.0 版源码</a><br>
<a target="_blank" rel="noopener" href="https://doris.apache.org/zh-CN/docs/dev/data-table/data-model">Doris官方文档-数据表设计&gt;数据模型</a><br>
<a target="_blank" rel="noopener" href="https://doris.apache.org/zh-CN/docs/dev/data-table/index/index-overview">Doris官方文档-数据表设计&gt;索引&gt;索引概述</a><br>
<a target="_blank" rel="noopener" href="https://doris.apache.org/zh-CN/docs/dev/data-table/best-practice">Doris官方文档-数据表设计&gt;最佳实践</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/426919326">悄悄学习Doris，偷偷惊艳所有人 | Apache Doris四万字小总结</a><br>
<a target="_blank" rel="noopener" href="https://www.modb.pro/db/583790">Doris数据模型----三种数据模型讲解的非常到位</a></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>在 Apache Doris 中，HLL（HyperLogLog）是一种用于基数估计的数据类型。它可以高效地估计一个集合中不同元素的数量，而无需存储实际的元素值。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在 Apache Doris 中，Bitmap 是一种用于高效压缩和查询位图索引数据的数据类型。它可以有效地表示包含大量重复值的列，并且在聚合、过滤和连接等操作中提供了显著的性能优势。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>yiyutingfeng
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://yiyutingfeng.github.io/2023/08/07/02/" title="Doris的数据模型">https://yiyutingfeng.github.io/2023/08/07/02/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Doris/" rel="tag"><i class="fa fa-tag"></i> Doris</a>
              <a href="/tags/Aggregate%E6%A8%A1%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> Aggregate模型</a>
              <a href="/tags/Unique%E6%A8%A1%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> Unique模型</a>
              <a href="/tags/Duplicate%E6%A8%A1%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> Duplicate模型</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/05/30/12/" rel="prev" title="如何通过hadoop访问s3存储桶">
                  <i class="fa fa-angle-left"></i> 如何通过hadoop访问s3存储桶
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">yiyutingfeng</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  






<script class="next-config" data-name="valine" type="application/json">{"enable":true,"appId":"6VXD9E0Vl3aN1kIDTufiLnbd-gzGzoHsz","appKey":"HCXYqYxY4dsV8Bj04VSEXau8","serverURLs":"https://6vxd9e0v.lc-cn-n1-shared.com","placeholder":"Just go go","avatar":"mm","meta":["nick","mail"],"pageSize":10,"lang":null,"visitor":false,"comment_count":true,"recordIP":false,"enableQQ":false,"requiredFields":["nick","mail"],"el":"#valine-comments","path":"/2023/08/07/02/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.valine.el)
    .then(() => NexT.utils.getScript(
      'https://fastly.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js',
      { condition: window.Valine }
    ))
    .then(() => {
      new Valine(CONFIG.valine);
    });
});
</script>

</body>
</html>
